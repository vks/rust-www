<!DOCTYPE html>
<!-- Page last generated 2018-09-10 15:05:18 +0000 -->
<html lang="ko-KR">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>자주 묻는 질문들 &middot; Rust 프로그래밍 언어</title>
    <meta name="keywords" content="Rust, Rust 프로그래밍 언어, rustlang, rust-lang, Mozilla Rust, 러스트, Mozilla, 모질라">
    <meta name="description" content="매우 빠르며, 세그폴트를 방지하고, 스레드 안전성을 보장하는 시스템 프로그래밍 언어">

    <link rel="stylesheet" href="/css/bootstrap.css">
    <link rel="stylesheet" href="/css/style.css">
    
  </head>

  <body class="container">
    <a href="https://github.com/rust-lang/rust">
      <img class="ribbon" style="display: none" src="/logos/forkme_ko_kr.svg" alt="GitHub에서 포크" width="298" height="298">
    </a>

    <header>
      <ul class="row menu">
	<li class="col-xs-12 col-md-2">
          <a href="/ko-KR/index.html">
            <img class="img-responsive" src="/logos/rust-logo-blk.svg" onerror="this.src='/logos/rust-logo-256x256-blk.png'" height="128" width="128" alt="Rust 로고" />
          </a>
	</li>
	<li class="col-xs-12 col-md-10 menu">
	  <h2><a href="/ko-KR/documentation.html">문서</a></h2>
	  <h2><a href="/ko-KR/install.html">설치</a></h2>
	  <h2><a href="/ko-KR/community.html">커뮤니티</a></h2>
	  <h2><a href="/ko-KR/contribute.html">기여하기</a></h2>
	</li>
      </ul>
    </header>

    <div class="content">
  <link href='https://fonts.googleapis.com/css?family=Source+Serif+Pro:400,600' rel='stylesheet' type='text/css'>
<link href='/css/syntax-highlight.css' rel='stylesheet' type='text/css'>

<div class="faq">
  <h1 id="section">자주 묻는 질문들</h1>

<p class="faq-intro">
이 문서는 Rust 프로그래밍 언어에 대한 흔한 질문들을 답하기 위해 존재합니다. 이 문서는 언어에 대한 완전한 안내서도 아니고, 언어를 가르치는 도구도 아닙니다. 이 문서는 Rust 커뮤니티에서 사람들이 되풀이하여 맞닥뜨리는 질문들을 답하고, Rust의 일부 설계가 왜 그렇게 결정되었는지를 밝히기 위한 참조서입니다.
</p>

<p class="faq-intro">
여기에서 답하지 않았지만 흔하거나 중요한 질문이 누락되어 있다고 생각하신다면 저희가 고칠 수 있도록 <a href="https://github.com/rust-lang/rust-www/blob/master/CONTRIBUTING.md">부담 없이 도와주세요</a>.
</p>

<div id="toc">
    <h2>목차</h2><a href="#toggle-toc"></a>
    <div class="contents">
        <ol id="toc-contents">
            <li><a href="#project">Rust 프로젝트</a></li>
            <li><a href="#performance">성능</a></li>
            <li><a href="#syntax">문법</a></li>
            <li><a href="#numerics">숫자</a></li>
            <li><a href="#strings">문자열</a></li>
            <li><a href="#collections">컬렉션</a></li>
            <li><a href="#ownership">소유권</a></li>
            <li><a href="#lifetimes">수명</a></li>
            <li><a href="#generics">일반화 (제너릭)</a></li>
            <li><a href="#input-output">입출력</a></li>
            <li><a href="#error-handling">오류 처리</a></li>
            <li><a href="#concurrency">동시성</a></li>
            <li><a href="#macros">매크로</a></li>
            <li><a href="#debugging">디버깅 및 도구</a></li>
            <li><a href="#low-level">저수준</a></li>
            <li><a href="#cross-platform">다중 플랫폼</a></li>
            <li><a href="#modules-and-crates">모듈 및 크레이트</a></li>
            <li><a href="#libraries">라이브러리</a></li>
            <li><a href="#design-patterns">디자인 패턴</a></li>
            <li><a href="#other-languages">다른 언어들</a></li>
            <li><a href="#documentation">문서</a></li>
        </ol>
    </div>
</div>

<h2 id="project">Rust 프로젝트</h2>

<h3><a href="#what-is-this-projects-goal" name="what-is-this-projects-goal">
이 프로젝트의 목표는 무엇입니까?
</a></h3>

<p>안전하고, 동시적이며, 실용적인 시스템 언어를 설계하고 구현하기 위함입니다.</p>

<p>Rust는 이 수준의 추상화와 효율을 추구하는 다른 언어들이 만족스럽지 못 하기에 존재합니다. 특히:</p>

<ol>
  <li>안전성이 너무 덜 주목되어 있습니다.</li>
  <li>동시성 지원이 부족합니다.</li>
  <li>실용적으로 쓰기가 힘듭니다.</li>
  <li>자원에 대한 제어가 제한적입니다.</li>
</ol>

<p>Rust는 효율적인 코드와 편안한 수준의 추상화를 제공하며, 동시에 위 4가지를 모두 개선하는 대안으로 만들어졌습니다.</p>

<h3><a href="#is-this-project-controlled-by-mozilla" name="is-this-project-controlled-by-mozilla">
이 프로젝트를 Mozilla가 제어하나요?
</a></h3>

<p>아니오. Rust는 2006년에 그레이던 호어(Graydon Hoare)가 시간을 쪼개서 하던 사이드 프로젝트로 시작하여 3년간 개발되었습니다.
2009년에 언어가 기본 테스트를 실행하고 핵심 개념들을 시연할 수 있을 정도로 성숙하자 Mozilla가 관여하기 시작했습니다.
Mozilla는 여전히 Rust를 지원하고 있습니다만, Rust는 전 세계의 많은 장소에 퍼져 있는 열정적인 사람들로 이루어진 커뮤니티가 개발하고 있습니다.
<a href="https://www.rust-lang.org/team.html">Rust 팀</a>은 Mozilla 직원들과 아닌 사람들 둘 다를 포함하고, GitHub의 <code class="highlighter-rouge">rust</code> 단체에는 <a href="https://github.com/rust-lang/rust/">1,900명 이상의 서로 다른 기여자</a>가 참여해 왔습니다.</p>

<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/1068-rust-governance.md">프로젝트 거버넌스</a>를 따라, Rust는 프로젝트의 비전과 우선 순위를 설정하는 코어 팀에 의해 관리되며 이 코어 팀이 전체적인 관점에서 프로젝트를 인도합니다.
또한 개별 관심 분야의 개발을 인도하고 장려하기 위한 서브팀들이 있으며, 핵심 언어, 컴파일러, Rust 라이브러리, Rust 도구, 그리고 공식 Rust 커뮤니티의 중재 등이 여기에 포함됩니다.
이들 각 분야 안에서의 설계는 <a href="https://github.com/rust-lang/rfcs">RFC 과정</a>을 통해 심화됩니다.
RFC를 필요로 하지 않는 수정은 <a href="https://github.com/rust-lang/rust"><code class="highlighter-rouge">rustc</code> 저장소</a>의 풀 요청(pull request)을 통해 결정이 내려집니다.</p>

<h3><a href="#what-are-some-non-goals" name="what-are-some-non-goals">
Rust의 목표가 아닌 것은 무엇이 있나요?
</a></h3>

<ol>
  <li>우리는 특별히 최신의 기술을 도입하지 않습니다. 오래되고 자리 잡힌 기술이 더 좋습니다.</li>
  <li>우리는 표현력, 최소주의 또는 우아함을 다른 목표에 우선하지 않습니다. 이들은 바람직하긴 하지만 부수적인 목표입니다.</li>
  <li>우리는 C++나 기타 다른 언어의 모든 기능 집합을 커버하려 하지 않습니다. Rust는 자주 쓰이는 기능들을 제공할 것입니다.</li>
  <li>우리는 100% 정적이거나, 100% 안전하거나, 100% 반영적(reflective)이거나, 기타 어떤 의미에서도 너무 교조적이려 하지 않습니다. 트레이드 오프는 존재합니다.</li>
  <li>우리는 Rust가 “가능한 모든 플랫폼”에서 동작할 걸 요구하지 않습니다. 언젠가 Rust는 널리 쓰이는 하드웨어와 소프트웨어 플랫폼에서 불필요한 타협 없이 동작할 것입니다.</li>
</ol>

<h3><a href="#how-does-mozilla-use-rust" name="how-does-mozilla-use-rust">
Mozilla에서 Rust를 사용하는 프로젝트가 무엇인가요?
</a></h3>

<p>주된 프로젝트는 Mozilla가 만들고 있는 실험적인 브라우저 엔진인 <a href="https://github.com/servo/servo">Servo</a>가 있습니다.
또한 파이어폭스에 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1135640">Rust 컴포넌트를 통합</a>하는 작업도 진행 중입니다.</p>

<h3><a href="#what-examples-are-there-of-large-rust-projects" name="what-examples-are-there-of-large-rust-projects">
대규모 Rust 프로젝트의 예제가 있나요?
</a></h3>

<p>현재 가장 큰 오픈소스 Rust 프로젝트로는 <a href="https://github.com/servo/servo">Servo</a>와 <a href="https://github.com/rust-lang/rust">Rust 컴파일러</a> 자신이 있습니다.</p>

<h3><a href="#who-else-is-using-rust" name="who-else-is-using-rust">
Rust를 쓰는 다른 곳이 있나요?
</a></h3>

<p><a href="friends.html">계속 늘어나고 있습니다!</a></p>

<!--
### What projects are good examples of idiomatic Rust code?

TODO: Write this answer.
-->

<h3><a href="#how-can-i-try-rust-easily" name="how-can-i-try-rust-easily">
Rust를 쉽게 시도해 보려면 어떻게 해야 하나요?
</a></h3>

<p>Rust를 시도해 보는 가장 쉬운 방법은 Rust 코드를 작성하고 실행할 수 있는 온라인 앱인 <a href="https://play.rust-lang.org/">플레이펜</a>을 통하는 것입니다.
여러분의 시스템에서 Rust를 시도해 보고 싶다면, <a href="https://www.rust-lang.org/install.html">설치</a> 후 《Rust 프로그래밍 언어》의 <a href="https://doc.rust-lang.org/stable/book/guessing-game.html">숫자 맞추기 게임</a> 지도서를 따라가세요.</p>

<h3><a href="#how-do-i-get-help-with-rust-issues" name="how-do-i-get-help-with-rust-issues">
Rust 문제들에 도움을 받으려면 어떻게 해야 하나요?
</a></h3>

<p>여러 방법이 있습니다:</p>

<ul>
  <li>공식 Rust 사용자 포럼인 <a href="https://users.rust-lang.org/">users.rust-lang.org</a>에 글을 올려 보세요.</li>
  <li>공식 <a href="https://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Rust IRC 채널</a>(#rust on irc.mozilla.org)에서 질문해 보세요.</li>
  <li><a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>에 “rust” 태그를 붙이고 질문해 보세요.</li>
  <li>비공식 Rust 서브레딧인 <a href="https://www.reddit.com/r/rust">/r/rust</a>에 글을 올려 보세요.</li>
</ul>

<h3><a href="#why-has-rust-changed-so-much" name="why-has-rust-changed-so-much">
Rust가 그동안 왜 그렇게 많이 바뀌었나요?
</a></h3>

<p>Rust는 안전하지만 쓸만한 시스템 프로그래밍 언어를 만들기 위한 목표로 출발했습니다.
이 목표를 달성하기 위해 수많은 아이디어들을 탐색했고, 그 중 일부는 채택되었지만(수명[lifetime], 트레이트) 다른 것들은 기각되었습니다(타입스테이트[type state] 시스템, 그린 스레딩).
또한 버전이 1.0에 근접하면서, Rust의 기능을 잘 사용하면서 질 좋고 일관된 크로스 플랫폼 API를 제공하기 위하여 표준 라이브러리의 많은 부분이 초기 설계로부터 재작성되었습니다.
이제 Rust가 1.0이 되면서 언어는 “안정화”되었다고 보장할 수 있고, 언어는 여전히 진화하겠지만 현재 Rust에서 작동하는 코드는 앞으로의 버전에서도 계속 작동할 것입니다.</p>

<h3><a href="#how-does-rust-language-versioning-work" name="how-does-rust-language-versioning-work">
Rust 언어의 버전은 어떻게 작동하나요?
</a></h3>

<p>Rust의 언어 버전은 <a href="http://semver.org/">유의적 버전(semantic versioning)</a>을 따릅니다.
부(部) 버전에서 안정화된 API의 호환성을 깨뜨리는 수정은, 그 수정이 컴파일러 버그를 고치거나, 안전성 구멍을 메꾸거나, 추가적인 타입 정보를 요구하는 방향으로 디스패치 및 타입 추론을 고칠 경우에만 허용됩니다.
부 버전 변경에 대한 더 자세한 가이드라인은 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md">언어</a> 및 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md">표준 라이브러리</a>에 대한 승낙된 RFC들에서 확인할 수 있습니다.</p>

<p>Rust는 세 개의 “릴리스 채널”, 즉 안정, 베타 및 나이틀리를 관리합니다.
안정 및 베타 버전은 매 6주마다 갱신되며, 기존의 나이틀리는 새 베타가 되고 기존의 베타는 새 안정 버전이 됩니다.
불안정하다고 표시되어 있거나 기능 게이트로 숨겨져 있는 언어 및 표준 라이브러리 기능은 나이틀리 버전에서만 사용할 수 있습니다.
새 기능은 불안정 상태로 도입되고, 코어 팀 및 유관한 서브팀이 재가하면 게이트가 “풀립니다”.
이런 접근을 통해 안정 버전들 사이에서는 강한 하위 호환성을 제공하면서 실험을 할 수 있습니다.</p>

<p>더 자세한 설명은 Rust 블로그의 <a href="http://blog.rust-lang.org/2014/10/30/Stability.html">“Stability as a Deliverable”</a> 글을 읽어 보세요.</p>

<h3><a href="#can-i-use-unstable-features-on-the-beta-or-stable-channel" name="can-i-use-unstable-features-on-the-beta-or-stable-channel">
불안정한 기능을 베타나 안정 버전에서 사용할 수 있나요?
</a></h3>

<p>아뇨, 사용할 수 없습니다.
Rust는 베타 및 안정 버전에 있는 기능들의 안정성에 강한 보장을 하려 애씁니다.
무언가가 불안정하다는 말은 우리가 아직 그 기능을 보장할 수 없다는 뜻이며, 사람들이 그게 똑같이 유지된다고 생각하며 의존하도록 하고 싶지 않다는 얘깁니다.
이렇게 함으로써 나이틀리 버전에서 야생의 수정을 시도할 기회를 얻는 동시에, 안정성을 원하는 사람들에게는 강한 보장이 여전히 제공됩니다.</p>

<p>매 버전마다 여러 기능들이 안정화되며, 베타 및 안정 버전은 매 6주마다 갱신됩니다.
종종 베타에는 수정 사항들이 반영되기도 합니다.
원하는 기능이 나이틀리 없이 사용 가능해지는 걸 기다리고 있다면, 이슈 트래커의 <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+tracking+label%3AB-unstable"><code class="highlighter-rouge">B-unstable</code></a> 태그를 확인해서 해당 기능을 추적하는 이슈를 찾아 볼 수 있습니다.</p>

<h3><a href="#what-are-feature-gates" name="what-are-feature-gates">
"기능 게이트"가 무엇인가요?
</a></h3>

<p>“기능 게이트”는 Rust가 컴파일러, 언어 및 표준 라이브러리 기능을 안정화하는 데 사용하는 기작입니다.
게이트에 “막혀 있는” 기능은 나이틀리 버전으로만 접근할 수 있고, 더불어 <code class="highlighter-rouge">#[feature]</code> 속성이나 <code class="highlighter-rouge">-Z unstable-options</code> 명령줄 인자로 명시적으로 켜져야만 합니다.
기능이 안정화되면 안정 버전에서 사용 가능해지며 명시적으로 켤 필요가 없습니다.
이 시점에서 기능은 게이트가 “풀렸다”고 봅니다.
기능 게이트를 쓰면 안정화된 언어에서 사용 가능해지기 전에 개발 도중의 실험적인 기능을 실험해 볼 수 있습니다.</p>

<h3><a href="#why-a-dual-mit-asl2-license" name="why-a-dual-mit-asl2-license">
MIT/ASL2 이중 라이선스를 쓰는 이유는 무엇인가요?
</a></h3>

<p>아파치 라이선스(ASL)는 특허권의 침해를 방지하는 중요한 장치가 있지만 GPL 버전 2와 호환되지 않습니다.
GPL2와 Rust를 함께 쓰는 데 문제가 없게 하기 위해 MIT로도 함께 라이선스되어 있습니다.</p>

<h3><a href="#why-a-permissive-license" name="why-a-permissive-license">
MPL이나 삼중 라이선스가 아니라 BSD 계열의 관대한(permissive) 라이선스를 쓰는 이유가 있나요?
</a></h3>

<p>어느 정도는 원 개발자(그레이던)가 그걸 좋아해서였고, 또 어느 정도는 언어들은 더 넓은 대중을 가지며 웹 브라우저 같은 제품과는 달리 더 다양한 곳에 포함되고 사용될 수 있기 때문이기도 합니다.
우리는 최대한 많은 잠재 기여자들에게 어필하려고 합니다.</p>

<h2 id="performance">성능</h2>

<h3><a href="#how-fast-is-rust" name="how-fast-is-rust">
Rust는 얼마나 빠른가요?
</a></h3>

<p>빠릅니다!
Rust는 이미 여러 벤치마크(이를테면 <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/rust.html">Benchmarks Game</a>이나 <a href="https://github.com/kostya/benchmarks">기타 이것 저것</a>)에서 관용적인 C 및 C++ 코드에 경쟁력이 있습니다.</p>

<p>C++와 동일하게 Rust는 <a href="http://blog.rust-lang.org/2015/05/11/traits.html">비용 없는 추상화</a>를 주요 원칙으로 삼습니다.
Rust에는 전역으로 성능을 떨어뜨리는 추상화가 존재하지 않으며, 런타임 시스템에서 부하가 발생하지도 않습니다.</p>

<p>Rust가 LLVM에 기반해 있고 LLVM이 보기에 Clang과 비슷하게 보이려 한다는 걸 생각해 보면, LLVM에서 성능 개선이 일어난다면 Rust도 도움을 받게 됩니다.
장기적으로는 Rust 타입 시스템의 더 풍부한 정보로 C/C++ 코드에서는 어렵거나 불가능한 최적화도 가능해질 것입니다.</p>

<h3><a href="#is-rust-garbage-collected" name="is-rust-garbage-collected">
Rust는 쓰레기 수거(garbage collection, GC)를 하나요?
</a></h3>

<p>아니요.
Rust의 중요 혁신 중 하나는 쓰레기 수거 <em>없이</em> 메모리 안전성을 보장한다는 것입니다(즉, 세그폴트가 나지 않습니다).</p>

<p>Rust는 GC를 피한 덕에 여러 장점을 제공할 수 있었습니다.
자원들을 예측 가능하게 해제할 수 있고, 메모리 관리 오버헤드가 낮으며, 사실상 런타임 시스템이 없습니다.
이 모든 특징들 때문에 Rust는 아무 맥락에나 깔끔하게 포함(embed)하기 쉬우며, <a href="http://calculist.org/blog/2015/12/23/neon-node-rust/">이미 GC를 가지고 있는 언어에 Rust 코드를 통합</a>하기에도 훨씬 쉽습니다.</p>

<p>Rust의 소유권 및 빌림(borrowing) 시스템은 GC를 쓸 필요를 없애지만, 같은 시스템으로 다른 문제들, 이를테면 <a href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">일반적인 자원 관리</a>나 <a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">동시성</a> 같은 것들에서도 도움을 받을 수 있습니다.</p>

<p>단일 소유권만으로 부족한 경우, Rust 프로그램은 GC 대신 표준적인 참조 카운팅 스마트 포인터 타입인 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code class="highlighter-rouge">Rc</code></a>와 이 타입의 스레드 안전한 버전인 <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code class="highlighter-rouge">Arc</code></a>에 의존합니다.</p>

<p>하지만 우리는 추후 확장으로 <em>선택 가능한</em> 쓰레기 수거를 조사하고 있습니다.
목표는 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey">Spidermonkey</a>나 <a href="https://developers.google.com/v8/?hl=en">V8</a> 자바스크립트 엔진 같은 곳에서 제공하는 쓰레기 수거 런타임에 매끄럽게 통합할 수 있게 하는 것입니다.
또한 몇몇 사람들은 컴파일러 지원 없이 <a href="https://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/">순수 Rust만으로 쓰레기 수거기를 만드는 시도</a>를 하기도 했습니다.</p>

<h3><a href="#why-is-my-program-slow" name="why-is-my-program-slow">
제 프로그램이 왜 느린 거죠?
</a></h3>

<p>Rust 컴파일러는 요청이 없다면 최적화 없이 컴파일을 하는데, 이는 <a href="https://users.rust-lang.org/t/why-does-cargo-build-not-optimise-by-default/4150/3">최적화를 하면 컴파일이 느려지고 개발 과정에서는 보통 바람직하지 않기 때문입니다</a>.</p>

<p><code class="highlighter-rouge">cargo</code>로 컴파일을 한다면 <code class="highlighter-rouge">--release</code> 플래그를 쓰세요.
<code class="highlighter-rouge">rustc</code>를 직접 써서 컴파일을 한다면 <code class="highlighter-rouge">-O</code> 플래그를 쓰세요.
어느 쪽이나 최적화를 켜는 역할을 합니다.</p>

<h3><a href="#why-is-rustc-slow" name="why-is-rustc-slow">
Rust 컴파일이 느린 것 같습니다. 왜 그런 건가요?
</a></h3>

<p>코드를 기계어로 번역하고 최적화를 하기 때문입니다.
Rust는 효율적인 기계어로 컴파일되는 고수준 추상화를 제공하고, 이 번역 과정은 특히 최적화를 할 경우 시간이 걸리게 마련입니다.</p>

<p>그러나 Rust의 컴파일 시간은 생각보다는 나쁜 편은 아니며, 앞으로 더 개선될 거라고 믿을 이유가 있습니다.
C++와 Rust로 비슷한 크기의 프로젝트를 비교해 보면 전체 프로젝트를 컴파일하는 시간은 일반적으로 비슷하다고 봅니다.
Rust 컴파일이 느리다고 느끼는 주된 원인은 C++와 Rust가 <em>컴파일 모델</em>이 다르다는 점, 즉 C++의 컴파일 단위는 한 파일이지만 Rust는 여러 파일로 이루어진 크레이트라는 것 때문입니다.
따라서 개발 도중에 C++ 파일 하나를 고치면 Rust에 비해 컴파일 시간이 훨씬 줄어들 수 있습니다.
현재 Rust 컴파일러를 리팩토링해서 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1298-incremental-compilation.md">증분 컴파일</a>을 가능하게 하려는 대형 작업이 진행 중이며, 완료되면 Rust에서도 C++ 모델과 같이 컴파일 시간이 개선될 것입니다.</p>

<p>컴파일 모델과는 별개로, Rust의 언어 설계에는 컴파일 시간에 영향을 미치는 요소가 여럿 있습니다.</p>

<p>먼저 Rust는 비교적 복잡한 타입 시스템을 가지고 있고, 실행 시간에 Rust를 안전하게 만들기 위한 제약 사항을 강제하는 데 무시할 수 없는 컴파일 시간을 사용해야 합니다.</p>

<p>두번째로 Rust 컴파일러에는 오래된 기술 부채가 있으며, 특히 생성되는 LLVM IR의 품질이 좋지 못하기 때문에 LLVM이 시간을 들여 이를 “고쳐야” 합니다.
미래에는 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md">MIR 기반</a> 최적화 및 번역 단계가 Rust 컴파일러가 LLVM에 가하는 부하를 줄여 줄지도 모릅니다.</p>

<p>세번째로 Rust가 코드 생성에 LLVM을 쓰는 것은 양날의 검이라는 점입니다.
LLVM 덕분에 Rust는 세계구급 런타임 성능을 보여 주지만, LLVM은 컴파일 시간에 촛점을 맞추지 않은 거대한 프레임워크이며 특히 품질이 낮은 입력에 취약합니다.</p>

<p>마지막으로 Rust가 일반화(제너릭) 타입을 C++와 비슷하게 단형화(monomorphise)하는 전략은 빠른 코드를 생성하지만, 다른 번역 전략에 비해 상당히 많은 코드를 생성해야 한다는 문제가 있습니다.
이 코드 팽창은 트레이트 객체를 써서 동적 디스패치와 장단을 교환할 수 있습니다.</p>

<h3><a href="#why-are-rusts-hashmaps-slow" name="why-are-rusts-hashmaps-slow">
Rust의 <code>HashMap</code>은 왜 느린가요?
</a></h3>

<p>Rust의 <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code class="highlighter-rouge">HashMap</code></a>은 기본적으로 <a href="https://131002.net/siphash/">SipHash</a> 해시 알고리즘을 사용합니다.
이 알고리즘은 <a href="http://programmingisterrible.com/post/40620375793/hash-table-denial-of-service-attacks-revisited">해시 테이블 충돌 공격</a>을 막으면서 <a href="https://www.reddit.com/r/rust/comments/3hw9zf/rust_hasher_comparisons/cub4oh6">여러 종류의 입력에 대해 적절한 성능을 내도록</a> 설계되었습니다.</p>

<p>SipHash가 많은 경우 <a href="http://cglab.ca/%7Eabeinges/blah/hash-rs/">경쟁력 있는 성능</a>을 보여 주긴 하지만, SipHash는 정수 같이 키가 짧을 경우 다른 해시 알고리즘에 비해 현저히 느립니다.
이 때문에 종종 <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code class="highlighter-rouge">HashMap</code></a>의 성능이 낮은 걸 볼 수 있습니다.
이런 경우에는 보통 <a href="https://crates.io/crates/fnv">FNV 해시</a>를 추천하지만, 이 알고리즘이 충돌 공격에서 SipHash와 다른 특성을 보인다는 점은 염두에 두어야 합니다.</p>

<h3><a href="#why-is-there-no-integrated-benchmarking" name="why-is-there-no-integrated-benchmarking">
왜 통합된 성능 측정 인프라가 없는 건가요?
</a></h3>

<p>있긴 한데요, 나이틀리 버전에만 있습니다.
궁극적으로는 착탈 가능한 통합 성능 측정 시스템을 만들 예정입니다만, 일단 현재 시스템은 <a href="https://github.com/rust-lang/rust/issues/29553">불안정하다고 여겨집니다</a>.</p>

<h3><a href="#does-rust-do-tail-call-optimization" name="does-rust-do-tail-call-optimization">
Rust는 꼬리 재귀(tail-call) 최적화를 하나요?
</a></h3>

<p>일반적으로는 아닙니다.
<a href="http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization">제한적으로</a> 꼬리 재귀 최적화를 하긴 하지만 <a href="https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html">보장되지는 않습니다</a>.
이 기능은 언제나 요청되어 왔기 때문에 Rust에는 이를 위해 예약어(<code class="highlighter-rouge">become</code>)가 예약되어 있습니다만, 이 기능이 기술적으로 가능한지, 그리고 가능하다면 구현이 될 것인지는 아직 불투명합니다.
특정한 맥락에서 꼬리 재귀 최적화를 하는 <a href="https://github.com/rust-lang/rfcs/pull/81">확장이 제안</a>되었지만 현재 보류된 상태입니다.</p>

<h3><a href="#does-rust-have-a-runtime" name="does-rust-have-a-runtime">
Rust에는 런타임이 있나요?
</a></h3>

<p>Java 같은 언어들에서 말하는 그런 통상의 런타임은 없습니다만, Rust 표준 라이브러리의 일부분은 힙(heap), 스택 추적(backtrace), 되감기(unwinding) 및 보호(guard)를 제공하는 “런타임”이라고 볼 수 있습니다.
사용자의 <code class="highlighter-rouge">main</code> 함수가 실행되기 전에는 <a href="https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src/libstd/rt.rs#L43">소량의 초기화 코드</a>가 실행됩니다.
또한 Rust 표준 라이브러리는 C 표준 라이브러리를 링크하는데 여기에서도 비슷한 <a href="http://www.embecosm.com/appnotes/ean9/html/ch05s02.html">런타임 초기화</a>가 일어납니다.
Rust 코드는 표준 라이브러리 없이 컴파일될 수 있으며 이 경우 런타임은 대략 C와 비슷해집니다.</p>

<h2 id="syntax">문법</h2>

<h3><a href="#why-curly-braces" name="why-curly-braces">
왜 중괄호인가요? Rust의 문법이 하스켈이나 파이썬 같지 않은 이유가 있나요?
</a></h3>

<p>중괄호를 블록에 사용하는 건 여러 프로그래밍 언어에서 흔히 쓰이는 설계이며, 이 스타일에 이미 익숙한 사람들한테는 Rust가 이를 따르는 쪽이 편리합니다.</p>

<p>또한 중괄호는 프로그래머 입장에서는 더 유연한 문법을 제공하고 컴파일러 입장에서는 더 간단한 파서를 가능하게 합니다.</p>

<h3><a href="#why-brackets-around-blocks" name="why-brackets-around-blocks">
<code>if</code> 조건에서 소괄호를 생략할 수 있는데, 그럼 한 줄짜리 블럭에는 왜 중괄호를 넣어야 하나요? C 같은 문법이 안 되는 이유가 있나요?
</a></h3>

<p>C에서는 <code class="highlighter-rouge">if</code> 조건문에서 괄호가 필수이고 중괄호가 선택이지만, Rust에서는 반대로 합니다.
이렇게 해서 조건문 몸체와 조건을 명확하게 구분할 수 있고, 중괄호가 선택이라서 벌어지는 위험도 막을 수 있는데, 이는 Apple의 <a href="https://gotofail.com/">goto fail</a> 버그와 같이 리팩토링 과정에서 흔히 생기고 잡기 어려운 오류들을 유발할 수 있습니다.</p>

<h3><a href="#why-no-literal-syntax-for-dictionaries" name="why-no-literal-syntax-for-dictionaries">
연관 배열의 리터럴 문법이 없는 이유는 무엇인가요?
</a></h3>

<p>Rust의 전반적인 설계는 <em>언어</em>의 크기를 제한하되 강력한 <em>라이브러리</em>를 만들 수 있게 하는 쪽을 선호합니다.
Rust는 배열과 문자열 리터럴을 초기화하는 문법을 가지고 있지만 언어에 내장된 컬렉션 타입은 이걸로 전부입니다.
매우 널리 쓰이는 <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec</code></a> 컬렉션 타입 같이, 라이브러리에서 정의하는 다른 타입들은 <a href="https://doc.rust-lang.org/stable/std/macro.vec!.html"><code class="highlighter-rouge">vec!</code></a> 같은 매크로를 사용하여 초기화를 합니다.</p>

<p>나중에는 Rust가 매크로를 써서 컬렉션을 초기화하는 설계가 다른 타입에도 일반적으로 사용할 수 있도록 확장될 수 있고, 그렇게 되면 <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code class="highlighter-rouge">HashMap</code></a>이나 <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec</code></a> 같은 것 뿐만이 아니라 <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html"><code class="highlighter-rouge">BTreeMap</code></a> 같은 다른 타입들도 간단하게 초기화할 수 있게 될 것입니다.
그 전에 컬렉션을 더 간단한 문법으로 초기화하고 싶다면 <a href="https://stackoverflow.com/questions/27582739/how-do-i-create-a-hashmap-literal">직접 매크로를 만들 수 있습니다</a>.</p>

<h3><a href="#when-should-i-use-an-implicit-return" name="when-should-i-use-an-implicit-return">
언제 암묵적인 반환을 써야 하나요?
</a></h3>

<p>Rust는 매우 수식 지향적인 언어이며 “암묵적인 반환”은 이 설계의 한 부분입니다.
<code class="highlighter-rouge">if</code>, <code class="highlighter-rouge">match</code>나 일반 블록들은 Rust에서는 다 수식입니다.
예를 들어 다음 코드는 <a href="https://doc.rust-lang.org/stable/std/primitive.i64.html"><code class="highlighter-rouge">i64</code></a>가 홀수인지 확인하고 결과를 단순히 값으로 내서 결과를 반환합니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">is_odd</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">true</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">false</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>물론 더 간단하게는 이렇게 쓰겠지만요:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">is_odd</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre>
</div>

<p>두 예제에서 함수의 마지막 줄은 그 함수의 반환값입니다.
중요한 것은 함수가 세미콜론으로 끝난다면 그 반환값은 <code class="highlighter-rouge">()</code>이고, 이는 반환값이 없다는 뜻이라는 점입니다.
암묵적으로 반환하려면 세미콜론이 없어야 합니다.</p>

<p>명시적인 반환은 함수 몸체의 맨 끄트머리보다 이전에 반환을 해야 해서 암묵적인 반환이 불가능할 때만 쓰입니다.
물론 위 함수들도 <code class="highlighter-rouge">return</code> 예약어와 세미콜론을 쓸 수는 있지만 불필요하게 번잡하고 Rust 코드의 규약에 어긋날 것입니다.</p>

<h3><a href="#why-arent-function-signatures-inferred" name="why-arent-function-signatures-inferred">
왜 함수의 타입 서명(signature)들은 추론되지 않는 거죠?
</a></h3>

<p>Rust에서 선언은 타입을 명시적으로 쓰는 편이며 실제 코드는 타입을 추론하는 편입니다.
이 설계에는 몇 가지 이유가 있습니다:</p>

<ul>
  <li>선언의 서명을 명시적으로 쓰면 모듈 및 크레이트 수준에서 인터페이스 안정성을 강제하는 데 도움이 됩니다.</li>
  <li>서명은 프로그래머가 코드를 더 잘 이해할 수 있게 하므로, IDE가 함수의 인자 타입들을 추측하려고 전체 크레이트에 추론 알고리즘을 돌릴 필요가 사라집니다. 언제나 명시적이고 바로 옆에 있기 때문이죠.</li>
  <li>기계적으로는 추론 과정에서 한 번에 한 함수만 보면 되므로 추론 알고리즘이 간단해집니다.</li>
</ul>

<h3><a href="#why-does-match-have-to-be-exhaustive" name="why-does-match-have-to-be-exhaustive">
왜 <code>match</code>에는 모든 조건들이 들어 있어야 하나요?
</a></h3>

<p>리팩토링을 돕고 코드를 명료하게 하기 위함입니다.</p>

<p>먼저, <code class="highlighter-rouge">match</code>가 모든 가능성을 커버하고 있다면 <code class="highlighter-rouge">enum</code>에 새 변종(variant)을 넣을 때 실행 시간에 오류가 나는 게 아니라 컴파일이 실패하게 됩니다.
Rust에서 이런 종류의 컴파일러 도움은 두려움 없이 리팩토링을 가능하게 합니다.</p>

<p>두 번째로, 이러한 체크는 기본 선택지를 명시적으로 만듭니다.
일반적으로 모든 가능성을 커버하지 않는 <code class="highlighter-rouge">match</code>를 안전하게 만드는 방법은 아무 선택지도 선택되지 않았을 때 스레드를 패닉하게 만드는 것 뿐입니다.
Rust의 옛 버전에서는 <code class="highlighter-rouge">match</code>가 모든 가능성을 커버하지 않아도 되게 했는데 수많은 버그의 온상이 되었습니다.</p>

<p>기술되지 않은 선택지는 <code class="highlighter-rouge">_</code> 와일드 카드로 간단하게 무시할 수 있습니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">match</span> <span class="n">val</span><span class="nf">.do_something</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">Cat</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="n">_</span>      <span class="k">=&gt;</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="numerics">숫자</h2>

<h3><a href="#which-type-of-float-should-i-use" name="which-type-of-float-should-i-use">
부동 소숫점 계산을 할 때 <code>f32</code>와 <code>f64</code> 중 어느 쪽을 선호해야 하나요?
</a></h3>

<p>프로그램의 목적에 따라 어느 쪽을 쓸지가 달라집니다.</p>

<p>만약 부동 소숫점 숫자가 최대한 정밀해야 한다면 <a href="https://doc.rust-lang.org/stable/std/primitive.f64.html"><code class="highlighter-rouge">f64</code></a>를 우선시하세요.
만약 크기를 작게 유지하거나 최대한의 성능을 얻고 싶고, 그에 따라 줄어드는 정밀도를 신경쓰지 않겠다면 <a href="https://doc.rust-lang.org/stable/std/primitive.f32.html"><code class="highlighter-rouge">f32</code></a>가 낫습니다.
64비트 하드웨어에서도 <a href="https://doc.rust-lang.org/stable/std/primitive.f32.html"><code class="highlighter-rouge">f32</code></a>가 보통 더 빠릅니다.
예를 들어 그래픽 프로그래밍에서는 높은 성능이 필요하고 화면 상의 픽셀을 표현하는 데는 32비트 부동 소숫점으로 충분하기 때문에 보통 <a href="https://doc.rust-lang.org/stable/std/primitive.f32.html"><code class="highlighter-rouge">f32</code></a>를 씁니다.</p>

<p>잘 모르겠으면 정밀도를 우선시해서 <a href="https://doc.rust-lang.org/stable/std/primitive.f64.html"><code class="highlighter-rouge">f64</code></a>를 선택하세요.</p>

<h3><a href="#why-cant-i-compare-floats" name="why-cant-i-compare-floats">
실수들을 비교하거나 <code>HashMap</code> 및 <code>BTreeMap</code>의 키로 쓸 수 없는 이유는 뭔가요?
</a></h3>

<p>실수들은 <code class="highlighter-rouge">==</code>, <code class="highlighter-rouge">!=</code>, <code class="highlighter-rouge">&lt;</code>, <code class="highlighter-rouge">&lt;=</code>, <code class="highlighter-rouge">&gt;</code> 및 <code class="highlighter-rouge">&gt;=</code> 연산자나 <code class="highlighter-rouge">partial_cmp()</code> 함수로 비교할 수 있습니다.
<code class="highlighter-rouge">==</code>와 <code class="highlighter-rouge">!=</code>는 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialEq.html"><code class="highlighter-rouge">PartialEq</code></a> 트레이트의 일부이고, <code class="highlighter-rouge">&lt;</code>, <code class="highlighter-rouge">&lt;=</code>, <code class="highlighter-rouge">&gt;</code>, <code class="highlighter-rouge">&gt;=</code> 및 <code class="highlighter-rouge">partial_cmp()</code>는 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialOrd.html"><code class="highlighter-rouge">PartialOrd</code></a> 트레이트의 일부입니다.</p>

<p>실수들은 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code class="highlighter-rouge">Ord</code></a> 트레이트에 있는 <code class="highlighter-rouge">cmp()</code> 함수로는 비교할 수 없는데 실수에는 전순서(total order)가 없기 때문입니다.
덧붙여 실수에는 전등치(total equality) 관계도 없으므로 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Eq.html"><code class="highlighter-rouge">Eq</code></a> 트레이트도 구현되어 있지 않습니다.</p>

<p>실수에 전순서나 전등치가 없는 이유는 부동 소숫점 실수에 있는 <a href="https://en.wikipedia.org/wiki/NaN"><code class="highlighter-rouge">NaN</code></a> 값은 다른 어떤 값이나 자기 자신보다 작지도, 크지도, 같지도 않기 때문입니다.</p>

<p>실수가 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Eq.html"><code class="highlighter-rouge">Eq</code></a>나 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code class="highlighter-rouge">Ord</code></a>를 구현하지 않으므로 이들 트레이트를 요구하는 타입에서는 사용 불가능하는데, 여기에는 <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html"><code class="highlighter-rouge">BTreeMap</code></a>이나 <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code class="highlighter-rouge">HashMap</code></a>도 들어갑니다.
이들 타입은 그 키가 전순서나 전등치를 가지고 있다고 <em>가정</em>하고, 그렇지 않다면 오동작할 것이므로 이 조건은 중요합니다.</p>

<p>다만, <a href="https://doc.rust-lang.org/stable/std/primitive.f32.html"><code class="highlighter-rouge">f32</code></a>와 <a href="https://doc.rust-lang.org/stable/std/primitive.f64.html"><code class="highlighter-rouge">f64</code></a>를 감싸서 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code class="highlighter-rouge">Ord</code></a>와 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Eq.html"><code class="highlighter-rouge">Eq</code></a> 구현을 제공하는 <a href="https://crates.io/crates/ordered-float">크레이트는 존재</a>하며 몇몇 상황에서 유용할 수 있습니다.</p>

<h3><a href="#how-can-i-convert-between-numeric-types" name="how-can-i-convert-between-numeric-types">
수치형들 사이에 변환을 하려면 어떻게 하나요?
</a></h3>

<p>두 가지 방법이 있는데, 하나는 <code class="highlighter-rouge">as</code> 예약어로 원시 타입 사이에서 간단한 변환을 하는 것이고, 다른 하나는 <a href="https://doc.rust-lang.org/stable/std/convert/trait.Into.html"><code class="highlighter-rouge">Into</code></a>와 <a href="https://doc.rust-lang.org/stable/std/convert/trait.From.html"><code class="highlighter-rouge">From</code></a> 트레이트를 써서 임의의 타입 변환을 하는 것입니다(트레이트를 직접 구현해서 변환을 추가할 수도 있습니다).
<a href="https://doc.rust-lang.org/stable/std/convert/trait.Into.html"><code class="highlighter-rouge">Into</code></a>와 <a href="https://doc.rust-lang.org/stable/std/convert/trait.From.html"><code class="highlighter-rouge">From</code></a> 트레이트는 변환에서 손실이 일어나지 않을 때만 구현되어 있으며, 이를테면 <code class="highlighter-rouge">f64::from(0f32)</code>는 컴파일이 되지만 <code class="highlighter-rouge">f32::from(0f64)</code>는 아닙니다.
한편 <code class="highlighter-rouge">as</code>는 원시 타입들 사이에서는 모두 변환이 가능하며 필요하다면 값을 잘라냅니다.</p>

<h3><a href="#why-doesnt-rust-have-increment-and-decrement-operators" name="why-doesnt-rust-have-increment-and-decrement-operators">
왜 Rust에는 증감 연산자가 없나요?
</a></h3>

<p>전위 및 후위 증감 연산자는 편하긴 하지만 꽤 복잡합니다.
이들 연산자를 쓰려면 연산 순서를 알아야 하고, C나 C++에서 이로 인한 미묘한 버그나 정의되지 않은 동작이 흔히 발생하지요.
<code class="highlighter-rouge">x = x + 1</code>이나 <code class="highlighter-rouge">x += 1</code>은 살짝 더 길 뿐이지만 모호하지 않습니다.</p>

<h2 id="strings">문자열</h2>

<h3><a href="#how-to-convert-string-or-vec-to-slice" name="how-to-convert-string-or-vec-to-slice">
<code>String</code>이나 <code>Vec&lt;T&gt;</code>를 슬라이스(<code>&amp;str</code> 및 <code>&amp;[T]</code>)로 어떻게 바꾸나요?
</a></h3>

<p>보통 슬라이스를 예상하는 곳에서는 <code class="highlighter-rouge">String</code>이나 <code class="highlighter-rouge">Vec&lt;T&gt;</code>의 참조를 넘길 수 있습니다.
<a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a>과 <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec</code></a>이 <code class="highlighter-rouge">&amp;</code>나 <code class="highlighter-rouge">&amp; mut</code> 참조로 넘겨질 때는 <a href="https://doc.rust-lang.org/stable/book/deref-coercions.html">deref 변환(coercion)</a>을 통해 각자 대응되는 슬라이스로 자동으로 변환됩니다.</p>

<p><code class="highlighter-rouge">&amp;str</code>과 <code class="highlighter-rouge">&amp;[T]</code>에 구현된 메소드들은 <code class="highlighter-rouge">String</code>과 <code class="highlighter-rouge">Vec&lt;T&gt;</code>에서 바로 접근할 수 있습니다.
예를 들어 <code class="highlighter-rouge">trim</code>은 <code class="highlighter-rouge">&amp;str</code>의 메소드이고 <code class="highlighter-rouge">some_string</code>이 <code class="highlighter-rouge">String</code>이라 하더라도 <code class="highlighter-rouge">some_string.trim()</code>은 동작할 것입니다.</p>

<p>일반화된 코드 같이 몇몇 상황에서는 수동으로 변환해야 할 필요가 있습니다.
수동 변환은 슬라이스 연산자를 써서 <code class="highlighter-rouge">&amp;my_vec[..]</code>과 같이 할 수 있습니다.</p>

<h3><a href="#how-to-convert-between-str-and-string" name="how-to-convert-between-str-and-string">
<code>&amp;str</code>를 <code>String</code>로 바꾸거나 반대로 하려면 어떻게 하나요?
</a></h3>

<p><a href="https://doc.rust-lang.org/stable/std/string/trait.ToString.html#tymethod.to_string"><code class="highlighter-rouge">to_string()</code></a> 메소드는 <a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">&amp;str</code></a>를 <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a>로 변환하고, <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a>에서 참조를 빌리면 <a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">&amp;str</code></a>로 자동으로 변환됩니다.
아래 예제는 두 가지 방향을 모두 시연합니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Jane Doe"</span><span class="nf">.to_string</span><span class="p">();</span>
    <span class="nf">say_hello</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">say_hello</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {}!"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3><a href="#what-are-the-differences-between-str-and-string" name="what-are-the-differences-between-str-and-string">
두 개의 다른 문자열 타입에 어떤 차이가 있나요?
</a></h3>

<p><a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a>은 힙에 할당된 UTF-8 바이트를 소유하는 버퍼입니다.
변경 가능한 <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a>은 수정할 수 있고 필요에 따라 그 용량(capacity)을 늘릴 수 있습니다.
<a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">&amp;str</code></a>은 다른 데 (보통 힙에) 할당되어 있는 <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a>으로부터 참조된 슬라이스나, 문자열 리터럴의 경우 정적 메모리를 가리키는, 용량이 고정된 “창”입니다.
<!-- TODO: the original text states that string literals are "allocated in static memory"? --></p>

<p><a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">&amp;str</code></a>은 Rust 언어가 구현하는 원시 타입이지만 <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a>은 표준 라이브러리에 구현되어 있습니다.</p>

<h3><a href="#how-do-i-do-o1-character-access-in-a-string" name="how-do-i-do-o1-character-access-in-a-string">
<code>String</code>의 각 문자를 O(1), 즉 상수 시간에 접근하려면 어떻게 해야 하나요?
</a></h3>

<p>불가능합니다.
적어도 “문자”가 무슨 의미인지 제대로 이해하고 있지 않거나, 원하는 문자의 인덱스를 찾으려 문자열을 전처리하지 않는다면 말이지요.</p>

<p>Rust 문자열은 UTF-8로 인코딩되어 있습니다.
보기에 하나의 문자는 UTF-8에서는 ASCII 문자열는 달리 꼭 한 바이트인 건 아닙니다.
각 바이트는 “코드 단위”라고 불립니다(UTF-16에서는 코드 단위가 2바이트이고 UTF-32에서는 4바이트이지요).
“코드포인트”는 하나 이상의 코드 단위로 구성되어 있고, 문자를 가장 가까이 근사한다고 할 수 있는 “자소(grapheme) 클러스터”는 여러 개의 코드포인트로 구성되어 있습니다.</p>

<p>따라서 UTF-8 문자열에서 바이트를 인덱싱할 수 있다 하더라도 상수 시간에 <code class="highlighter-rouge">i</code>번째 코드포인트나 자소 클러스터를 얻어낼 수는 없습니다.
하지만 원하는 코드포인트나 자소 클러스터가 어느 바이트에서 시작하는지 안다면 <em>그건</em> 상수 시간에 접근할 수 있습니다.
<a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.find"><code class="highlighter-rouge">str::find()</code></a>나 정규식 검색 결과는 바이트 인덱스를 반환하므로 이 방법으로 접근하는 게 가능합니다.</p>

<h3><a href="#why-are-strings-utf-8" name="why-are-strings-utf-8">
왜 문자열이 기본적으로 UTF-8인가요?
</a></h3>

<p><a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">str</code></a> 타입이 UTF-8인 것은 현실에서, 특히 엔디안이 정해져 있지 않은 네트워크 전송에서 이 인코딩이 널리 쓰이기 때문이고, I/O를 할 때 어느 방향에서도 코드포인트를 다시 변환할 필요가 없는 것이 최선이라고 생각하기 때문입니다.</p>

<p>물론 이는 문자열 안의 특정 유니코드 코드포인트의 위치를 찾는데 O(n) 연산이 필요하다는 뜻이긴 합니다.
이미 시작하는 바이트 인덱스를 알고 있을 경우에는 예상대로 O(1) 시간이 걸리겠지만요.
어떻게 보면 바람직하지 않을 수도 있지만, 어떻게 보면 이 문제 자체가 트레이드오프로 가득 차 있기에 다음 중요한 점들을 지적할 필요가 있겠습니다:</p>

<p><a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">str</code></a>에서 ASCII 영역의 코드포인트를 훑는 건 바이트 단위로 안전하게 할 수 있습니다.
<a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.as_bytes"><code class="highlighter-rouge">.as_bytes()</code></a>를 쓸 경우 <a href="https://doc.rust-lang.org/stable/std/primitive.u8.html"><code class="highlighter-rouge">u8</code></a>을 얻는 건 <code class="highlighter-rouge">O(1)</code> 연산이며 이 값은 ASCII 범위의 <a href="https://doc.rust-lang.org/stable/std/primitive.char.html"><code class="highlighter-rouge">char</code></a>로 변환하거나 비교할 수 있습니다.
그러니까 이를테면 <code class="highlighter-rouge">'\n'</code>로 줄 바꿈을 찾는다면 바이트 단위로 검색해도 됩니다.
UTF-8은 원래부터 이렇게 설계되었거든요.</p>

<p>대부분의 “문자 기반” 텍스트 연산들은 “ASCII 범위의 코드포인트 한정” 같이 매우 제약된 언어 가정이 있어야만 동작합니다.
ASCII 범위를 벗어나면 언어학적인 단위들(글리프, 낱말, 문단)의 경계를 찾기 위해 (상수 시간이 아닌) 복잡한 알고리즘을 써야 하기 마련입니다.
저희는 “솔직한”, 언어학적으로 올바르며 유니코드에서 인증한 알고리즘을 권장합니다.</p>

<p><a href="https://doc.rust-lang.org/stable/std/primitive.char.html"><code class="highlighter-rouge">char</code></a> 타입은 UTF-32입니다.
한 번에 한 코드포인트를 들여다 보는 알고리즘이 정말로 필요하다고 생각한다면 <code class="highlighter-rouge">type wstr = [char]</code>을 정의하여 <a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">str</code></a>로부터 한번에 읽어들인 뒤 <code class="highlighter-rouge">wstr</code>에서 연산을 하면 됩니다.
다르게 말하면, 언어가 “기본적으로 UTF-32로 디코딩하지 않는다”고 해서 UTF-32로 디코딩하거나 다시 인코딩하는 것 자체가 불가능한 건 아니라는 말입니다.</p>

<p>왜 UTF-8이 UTF-16이나 UTF-32보다 보통 더 선호되는지 자세한 설명을 원한다면 <a href="http://utf8everywhere.org/">UTF-8 Everywhere manifesto</a>를 읽어 보시길 바랍니다.</p>

<h3><a href="#what-string-type-should-i-use" name="what-string-type-should-i-use">
어떤 문자열 타입을 써야 하죠?
</a></h3>

<p>Rust는 네 쌍의 문자열 타입이 있고 <a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">각각 다른 역할을 합니다</a>.
각 쌍마다 “소유된” 문자열 타입과 “슬라이스” 문자열 타입이 따로 있고, 다음과 같이 구성되어 있습니다:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: left">“슬라이스” 타입</th>
      <th style="text-align: left">“소유된” 타입</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">UTF-8</td>
      <td style="text-align: left"><code class="highlighter-rouge">str</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">String</code></td>
    </tr>
    <tr>
      <td style="text-align: left">OS 호환용</td>
      <td style="text-align: left"><code class="highlighter-rouge">OsStr</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">OsString</code></td>
    </tr>
    <tr>
      <td style="text-align: left">C 호환용</td>
      <td style="text-align: left"><code class="highlighter-rouge">CStr</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">CString</code></td>
    </tr>
    <tr>
      <td style="text-align: left">시스템 경로</td>
      <td style="text-align: left"><code class="highlighter-rouge">Path</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">PathBuf</code></td>
    </tr>
  </tbody>
</table>

<p>Rust의 서로 다른 문자열 타입은 각자 다른 목적을 가집니다.
<code class="highlighter-rouge">String</code>과 <code class="highlighter-rouge">str</code>은 UTF-8로 인코딩된 일반 목적의 문자열입니다.
<code class="highlighter-rouge">OsString</code>과 <code class="highlighter-rouge">OsStr</code>은 현재 플랫폼에 맞춰 인코딩되어 있고 운영체제와 상호작용할 때 쓰입니다.
<code class="highlighter-rouge">CString</code>과 <code class="highlighter-rouge">CStr</code>은 C 문자열의 Rust 버전으로 FFI 코드에 사용되고, <code class="highlighter-rouge">PathBuf</code>와 <code class="highlighter-rouge">Path</code>는 <code class="highlighter-rouge">OsString</code>과 <code class="highlighter-rouge">OsStr</code>에 편의를 위해 경로 조작을 위한 메소드들을 추가한 것입니다.</p>

<h3><a href="#why-are-there-multiple-types-of-strings" name="why-are-there-multiple-types-of-strings">
<code>&amp;str</code>와 <code>String</code>을 동시에 받는 함수를 어떻게 짤 수 있나요?
</a></h3>

<p>함수의 요구 사항에 따라 여러 선택이 있습니다:</p>

<ul>
  <li>함수가 소유된 문자열을 필요로 하지만 아무 문자열 타입이나 받고 싶다면, <code class="highlighter-rouge">Into&lt;String&gt;</code> 제약을 쓰세요.</li>
  <li>함수가 문자열 슬라이스를 필요로 하지만 아무 문자열 타입이나 받고 싶다면, <code class="highlighter-rouge">AsRef&lt;str&gt;</code> 제약을 쓰세요.</li>
  <li>함수가 문자열 타입에 대해 신경쓰지 않고 두 가능성을 일관되게 처리하고 싶다면, 입력 타입으로 <code class="highlighter-rouge">Cow&lt;str&gt;</code>을 쓰세요.</li>
</ul>

<p><strong><code class="highlighter-rouge">Into&lt;String&gt;</code>의 사용</strong></p>

<p>이 예제에서 함수는 소유된 문자열과 문자열 슬라이스를 둘 다 받으며, 어느 쪽인지에 따라 함수 몸체 안에서 아무 일도 하지 않거나 입력을 소유된 문자열로 변환합니다.
참고로 변환은 명시적으로 해야 하며 안 그러면 변환되지 않을 것입니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="n">accepts_both</span><span class="o">&lt;</span><span class="n">S</span><span class="p">:</span> <span class="n">Into</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.into</span><span class="p">();</span>   <span class="c">// s를 `String`으로 변환합니다.</span>
    <span class="c">// ... 함수의 나머지 내용</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong><code class="highlighter-rouge">AsRef&lt;str&gt;</code>의 사용</strong></p>

<p>이 예제에서 함수는 소유된 문자열과 문자열 슬라이스를 둘 다 받으며, 어느 쪽인지에 따라 아무 일도 하지 않거나 입력을 문자열 슬라이스로 변환합니다.
이는 입력을 참조로 받아서 다음과 같이 자동으로 일어나게 할 수 있습니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="n">accepts_both</span><span class="o">&lt;</span><span class="n">S</span><span class="p">:</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ... 함수의 몸체</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong><code class="highlighter-rouge">Cow&lt;str&gt;</code>의 사용</strong></p>

<p>이 예제에서 함수는 <code class="highlighter-rouge">Cow&lt;str&gt;</code>을 받는데, 이는 일반화된 타입이 아니라 컨테이너로서 필요에 따라 소유된 문자열이나 문자열 슬라이스를 담을 수 있습니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">accepts_cow</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Cow</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ... 함수의 몸체</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="collections">컬렉션</h2>

<h3><a href="#can-i-implement-linked-lists-in-rust" name="can-i-implement-linked-lists-in-rust">
Rust로 벡터나 연결 리스트 같은 자료 구조를 효율적으로 구현할 수 있나요?
</a></h3>

<p>만약 이들 자료 구조를 구현하려는 이유가 다른 프로그램에서 그걸 사용하려는 거라면 표준 라이브러리에 효율적인 구현들이 존재하므로 그럴 필요는 없습니다.</p>

<p>하지만, 만약 <a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">단순히 공부를 위해서라면</a> 안전하지 않은 코드에 발을 들일 필요가 있을 겁니다.
이들 자료 구조들이 안전한 Rust만으로도 구현할 수<em>는</em> 있지만, 안전하지 않은 코드를 사용하는 것보다 성능이 떨어질 가능성이 높습니다.
간단하게 이유를 말하자면 벡터나 연결 리스트 같은 자료 구조들은 안전한 Rust에서 허용되지 않는 포인터와 메모리 연산에 의존하기 때문입니다.</p>

<p>예를 들어 양방향 연결 리스트에서는 각 노드마다 두 개의 변경 가능한 참조를 가져야 하는데 이는 Rust에서 변경 가능한 참조가 별명(alias)을 가질 수 없다는 규칙을 위배합니다.
<a href="https://doc.rust-lang.org/stable/std/rc/struct.Weak.html"><code class="highlighter-rouge">Weak&lt;T&gt;</code></a>로 이 문제를 해결할 수 있지만 보통 원하는 것보다 성능이 떨어질 것입니다.
안전하지 않은 코드를 쓰면 이 별명 규칙을 우회할 수 있지만, 메모리 안전성을 위배하는 코드가 없다는 걸 수동으로 검증해야 합니다.</p>

<h3><a href="#how-can-i-iterate-over-a-collection-without-consuming-it" name="how-can-i-iterate-over-a-collection-without-consuming-it">
컬렉션을 움직이거나 소모(consume)하지 않고 각 원소에 대해 반복하려면 어떻게 하나요?
</a></h3>

<p>가장 쉬운 방법은 컬렉션의 <a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code class="highlighter-rouge">IntoIterator</code></a> 구현을 사용하는 겁니다.
다음은 <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">&amp;Vec</code></a>을 쓰는 예제입니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="k">for</span> <span class="n">item</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">v</span> <span class="p">{</span>
    <span class="nd">print!</span><span class="p">(</span><span class="s">"{} "</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Length: {}"</span><span class="p">,</span> <span class="n">v</span><span class="nf">.len</span><span class="p">());</span>
</code></pre>
</div>

<p>Rust의 <code class="highlighter-rouge">for</code> 반복문은 반복하고자 하는 대상에 대해 (<a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code class="highlighter-rouge">IntoIterator</code></a> 트레이트에 정의된) <code class="highlighter-rouge">into_iter()</code>를 호출합니다.
<a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code class="highlighter-rouge">IntoIterator</code></a> 트레이트를 구현하는 아무 값이나 <code class="highlighter-rouge">for</code> 반복문에서 사용할 수 있습니다.
<a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code class="highlighter-rouge">IntoIterator</code></a>는 <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">&amp;Vec</code></a>과 <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">&amp;mut Vec</code></a>에 구현되어 있으며, 이 경우 <code class="highlighter-rouge">into_iter()</code>가 컬렉션을 옮기거나 소모하는 것이 아니라 그 내용물을 빌리도록 합니다.
다른 표준 컬렉션에 대해서도 똑같은 관계가 성립합니다.</p>

<p>만약 옮기거나 소모하는 반복자가 필요하다면 <code class="highlighter-rouge">for</code> 반복문에서 반복할 때 <code class="highlighter-rouge">&amp;</code>나 <code class="highlighter-rouge">&amp;mut</code> 없이 쓰세요.</p>

<p>빌리는 반복자를 직접 접근하고 싶다면 보통 <code class="highlighter-rouge">iter()</code> 메소드를 써서 얻을 수 있습니다.</p>

<h3><a href="#why-do-i-need-to-type-the-array-size-in-the-array-declaration" name="why-do-i-need-to-type-the-array-size-in-the-array-declaration">
배열 선언에 배열 크기를 넣어야 하는 이유가 무엇인가요?
</a></h3>

<p>꼭 그럴 필요는 없습니다.
배열을 직접 선언한다면 원소의 갯수로부터 크기가 추론됩니다.
하지만 고정된 크기의 배열을 받는 함수를 선언한다면 컴파일러가 배열이 얼마나 클 지를 알아야 합니다.</p>

<p>하나 짚고 넘어가야 하는 게 있는데, Rust는 현재 서로 다른 크기의 배열에 대해 일반화를 지원하지 않습니다.
만약 갯수가 바뀔 수 있는 값들의 연속된 컨테이너를 받고자 한다면 (소유권이 필요하냐 마냐에 따라) <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec</code></a>이나 슬라이스를 사용하세요.</p>

<h2 id="ownership">소유권</h2>

<h3><a href="#how-can-i-implement-a-data-structure-that-contains-cycles" name="how-can-i-implement-a-data-structure-that-contains-cycles">
그래프 같이 사이클을 포함하는 자료 구조를 구현하려면 어떻게 해야 하나요?
</a></h3>

<p>적어도 네 가지 선택이 있습니다(<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">Too Many Linked Lists</a>에서 더 길게 설명합니다):</p>

<ul>
  <li><a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code class="highlighter-rouge">Rc</code></a>와 <a href="https://doc.rust-lang.org/stable/std/rc/struct.Weak.html"><code class="highlighter-rouge">Weak</code></a>을 써서 노드가 공유된 소유권을 가질 수 있게 하여 구현할 수 있습니다. 다만 이 접근은 메모리 관리 비용을 치뤄야 합니다.</li>
  <li><code class="highlighter-rouge">unsafe</code> 코드에서 생 포인터를 사용해서 구현할 수 있습니다. 더 효율적이지만 Rust의 안전성 보장을 우회합니다.</li>
  <li>벡터와 그 벡터에 대한 인덱스를 사용합니다. 이 접근에 대한 <a href="http://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/">여러</a> <a href="https://featherweightmusings.blogspot.com/2015/04/graphs-in-rust.html">가지</a> 예제와 설명이 있습니다.</li>
  <li><a href="https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html"><code class="highlighter-rouge">UnsafeCell</code></a>와 함께 빌린 참조를 사용합니다. 이 접근에 대해서 <a href="https://github.com/nrc/r4cppp/blob/master/graphs/README.md#node-and-unsafecell">설명과 코드</a>가 준비되어 있습니다.</li>
</ul>

<h3><a href="#how-can-i-define-a-struct-that-contains-a-reference-to-one-of-its-own-fields" name="how-can-i-define-a-struct-that-contains-a-reference-to-one-of-its-own-fields">
자기 자신의 필드를 가리키는 참조를 가진 구조체는 어떻게 선언해야 하나요?
</a></h3>

<p>가능하지만 의미가 없습니다.
구조체는 자기 자신을 영구히 빌리게 되며 따라서 더 이상 움직일 수 없게 됩니다.
다음 코드가 이런 상황을 보여 줍니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">Cell</span><span class="p">;</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Unmovable</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="err">'</span><span class="n">a</span> <span class="nb">u32</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">test</span> <span class="o">=</span> <span class="n">Unmovable</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nn">Cell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span> <span class="p">};</span>
    <span class="n">test</span><span class="py">.y</span><span class="nf">.set</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test</span><span class="py">.x</span><span class="p">));</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">test</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3><a href="#what-is-the-difference-between-consuming-and-moving" name="what-is-the-difference-between-consuming-and-moving">
값으로 호출하기, 소모(consume)하기, 움직이기, 그리고 소유권을 넘기기에 서로 무슨 차이가 있나요?
</a></h3>

<p>다 같은 뜻입니다.
네 가지 경우에서 모두, 값이 새 소유자에게 옮겨가고, 원 소유자가 소유를 잃어버려 더 이상 쓸 수 없게 됩니다.
만약 타입이 <code class="highlighter-rouge">Copy</code> 트레이트를 구현한다면 원 소유자의 값은 무효화되지 않아 계속 쓸 수 있습니다.</p>

<h3><a href="#why-can-values-of-some-types-by-reused-while-others-are-consumed" name="why-can-values-of-some-types-by-reused-while-others-are-consumed">
왜 어떤 타입은 함수에 넘긴 뒤에도 재사용할 수 있지만 다른 타입은 그렇지 않나요?
</a></h3>

<p>타입이 <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">Copy</code></a> 트레이트를 구현하면 함수에 전달될 때 복사됩니다.
Rust의 모든 수치형은 <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">Copy</code></a>를 구현하지만, 구조체는 기본적으로 <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">Copy</code></a>를 구현하지 않기 때문에 대신 이동이 일어납니다.
즉 구조체는 함수에서 다시 반환되거나 하지 않는 한 더 이상 다른 데서 사용할 수 없게 됩니다.</p>

<h3><a href="#how-do-you-deal-with-a-use-of-moved-value-error" name="how-do-you-deal-with-a-use-of-moved-value-error">
"움직인 값을 사용"(use of moved value)했다는 오류를 어떻게 다뤄야 하나요?
</a></h3>

<p>이 오류는 사용하려는 값이 새 소유권자에게 옮겨갔다는 뜻입니다.
먼저 문제의 옮김이 정말로 필요한 것이었는가를 확인해 보세요.
값이 함수 안으로 옮겨갔다면 함수가 대신 참조를 쓰도록 재작성해야 할 수도 있습니다.
그게 아니고, 만약 옮겨가는 타입이 <a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html#tymethod.clone"><code class="highlighter-rouge">Clone</code></a>을 구현할 경우, 옮겨가기 전에 <code class="highlighter-rouge">clone()</code>을 호출하면 값의 복사본이 옮겨가고 원래 값은 계속 쓸 수 있게 됩니다.
다만 값을 복제하는 건 일반적으로 최후의 수단이어야 하는데, 복제가 추가로 할당을 일으켜 비쌀 수 있기 때문입니다.</p>

<p>옮겨가는 값의 타입이 직접 만든 것이라면, (옮겨가는 대신 암묵적으로 복사를 할 경우) <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">Copy</code></a>나 (명시적으로 복사할 경우) <a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html#tymethod.clone"><code class="highlighter-rouge">Clone</code></a>을 구현하는 걸 생각해 보세요.
<a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">Copy</code></a>은 대부분 <code class="highlighter-rouge">#[derive(Copy, Clone)]</code>로 구현되고(<a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">Copy</code></a>는 <a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html#tymethod.clone"><code class="highlighter-rouge">Clone</code></a>를 필요로 합니다), <a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html#tymethod.clone"><code class="highlighter-rouge">Clone</code></a>은 <code class="highlighter-rouge">#[derive(Clone)]</code>로 구현합니다.</p>

<p>어느 쪽도 가능하지 않다면 함수를 고쳐서, 소유권을 얻은 함수에서 나갈 때 그 값의 소유권을 반환하도록 해야 할 수 있습니다.</p>

<h3><a href="#what-are-the-rules-for-different-self-types-in-methods" name="what-are-the-rules-for-different-self-types-in-methods">
메소드 선언에서 언제 <code>self</code>, <code>&amp;self</code>, 또는 <code>&amp;mut self</code>를 쓰는지 규칙이 있나요?
</a></h3>

<ul>
  <li>함수가 값을 소모해야 한다면 <code class="highlighter-rouge">self</code>를 쓰세요.</li>
  <li>함수가 값에 대한 읽기 전용 참조만 필요하다면 <code class="highlighter-rouge">&amp;self</code>를 쓰세요.</li>
  <li>함수가 값을 소모하지 않으면서 값을 변경해야 한다면 <code class="highlighter-rouge">&amp;mut self</code>를 쓰세요.</li>
</ul>

<h3><a href="#how-can-i-understand-the-borrow-checker" name="how-can-i-understand-the-borrow-checker">
빌림 체커(borrow checker)를 이해하는 방법은 무엇인가요?
</a></h3>

<p>빌림 체커는 Rust 코드를 평가하는 과정에서 오로지 몇 가지 규칙만 적용하는데, 《Rust 프로그래밍 언어》의 <a href="https://doc.rust-lang.org/stable/book/references-and-borrowing.html#the-rules">빌림(borrowing) 장</a>에서 확인할 수 있습니다.
이 규칙은 다음과 같습니다:</p>

<blockquote>
  <p>첫째, 모든 빌림은 소유권자의 그것보다 작거나 같은 범위(scope)동안 지속되어야 합니다.
둘째, 다음 두 종류의 빌림 중 하나를 가질 수 있지만 둘을 동시에 가질 수는 없습니다:</p>

  <ul>
    <li>자원에 대한 하나 이상의 참조 (&amp;T)</li>
    <li>정확히 하나의 변경 가능한 참조 (&amp;mut T)</li>
  </ul>
</blockquote>

<p>규칙들 자체는 간단하지만 이를 일관되게 지키는 건, 특히 수명과 소유권에 대해 생각하는 습관이 들지 않았을 경우 간단하지 않습니다.</p>

<p>빌림 체커를 이해하는 첫 단계는 산출된 오류를 읽는 것입니다.
빌림 체커를 인식된 문제를 해결하는 데 양질의 도움을 제공하게 하려 많은 노력이 투자되었습니다.
빌림 체커 문제를 만났을 때는 먼저 보고된 오류를 느리고 주의 깊게 읽고, 설명된 오류를 이해한 뒤에야 코드를 접근할 수 있습니다.</p>

<p>두번째 단계는 <a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html"><code class="highlighter-rouge">Cell</code></a>, <a href="https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html"><code class="highlighter-rouge">RefCell</code></a>, 그리고 <a href="https://doc.rust-lang.org/stable/std/borrow/enum.Cow.html"><code class="highlighter-rouge">Cow</code></a> 같이 Rust 표준 라이브러리가 제공하는, 소유권 및 변경 가능성에 관련된 컨테이너 타입들에 친숙해지는 것입니다.
이들은 특정한 소유권 및 변경 가능성 상황을 표현하는 데 유용하고 필요한 도구로, 최소한의 성능 비용만 지불하도록 작성되었습니다.</p>

<p>빌림 체커를 이해하는 데 가장 중요한 부분은 연습입니다.
Rust의 강력한 정적 분석 보장은 많은 프로그래머가 이전에 겪어 본 것에 비해 엄격하고 꽤 다릅니다.
모든 것에 완전히 익숙해지려면 얼마간의 시간이 필요할 것입니다.</p>

<p>만약 빌림 체커와 다투고 있거나 인내가 바닥이 났다면, 언제든 <a href="community.html">Rust 커뮤니티</a>에 도움을 청해 보세요.</p>

<h3><a href="#when-is-rc-useful" name="when-is-rc-useful">
<code>Rc</code>가 유용한 때는 언제인가요?
</a></h3>

<p><a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code class="highlighter-rouge">Rc</code></a>는 Rust의 원자적이지 않은 참조 카운팅되는 포인터 타입으로, 이 질문은 공식 문서에서 커버하고 있습니다.
요약하자면 <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code class="highlighter-rouge">Rc</code></a> 및 스레드 안전한 버전인 <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code class="highlighter-rouge">Arc</code></a>는 공유된 소유권을 표현하는 데 유용하고, 아무도 접근하지 않을 때 연관된 메모리를 시스템이 자동으로 해제하도록 합니다.</p>

<h3><a href="#how-do-i-return-a-closure-from-a-function" name="how-do-i-return-a-closure-from-a-function">
함수에서 어떻게 클로저를 반환하나요?
</a></h3>

<p>함수에서 클로저를 반환하려면 그 클로저는 “이동 클로저”로, 클로저가 <code class="highlighter-rouge">move</code> 예약어로 선언되었어야만 합니다.
<a href="https://doc.rust-lang.org/book/closures.html#move-closures">《Rust 프로그래밍 언어》에서 설명</a>하듯, 이 예약어는 클로저가 갈무리된 변수들을 부모 스택 프레임과 무관한 사본으로 가지게 합니다.
안 그랬다가는, 클로저를 반환하면 더 이상 올바르지 않은 변수에 접근할 수 있게 될테니 안전하지 않게 됩니다.
다르게 말하면 잠재적으로 잘못된 메모리를 읽을 수 있게 된단 얘기죠.
클로저는 또한 <a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html"><code class="highlighter-rouge">Box</code></a>로 감싸져 있어서 힙에 할당되어야만 합니다.
《<a href="https://doc.rust-lang.org/book/closures.html#returning-closures">Rust 프로그래밍 언어</a>》에서 자세한 내용을 읽어 보세요.</p>

<h3><a href="#what-are-deref-coercions" name="what-are-deref-coercions">
Deref 변환(coercion)이 무엇이고 어떻게 동작하나요?
</a></h3>

<p><a href="https://doc.rust-lang.org/book/deref-coercions.html">Deref 변환</a>은 포인터에 대한 참조(예를 들어 <code class="highlighter-rouge">&amp;Rc&lt;T&gt;</code>나 <code class="highlighter-rouge">&amp;Box&lt;T&gt;</code>)를 자동으로 그 내용물의 참조(예를 들어 <code class="highlighter-rouge">&amp;T</code>)로 변환하는 편리한 변환입니다.
Deref 변환은 Rust를 더 사용하기 편리하게 하려 존재하며, <a href="https://doc.rust-lang.org/stable/std/ops/trait.Deref.html"><code class="highlighter-rouge">Deref</code></a> 트레이트를 통해 구현됩니다.</p>

<p>Deref 구현은 구현하는 타입이 <code class="highlighter-rouge">deref</code> 메소드를 호출하여 대상 타입으로 변환될 수 있다는 걸 나타냅니다.
이 메소드는 호출되는 타입의 변경 불가능한 참조를 받아서 (같은 수명을 가지는) 대상 타입의 참조를 반환합니다.
<code class="highlighter-rouge">*</code> 전위 연산자는 <code class="highlighter-rouge">deref</code> 메소드의 축약입니다.</p>

<p>이들이 “변환”이라 불리는 건 《<a href="https://doc.rust-lang.org/stable/book/deref-coercions.html">Rust 프로그래밍 언어</a>》에서 언급하듯 다음 규칙 때문입니다:</p>

<blockquote>
  <p>만약 타입 <code class="highlighter-rouge">U</code>가 <code class="highlighter-rouge">Deref&lt;Target=T&gt;</code>를 구현하면, <code class="highlighter-rouge">&amp;U</code> 값은 자동으로 <code class="highlighter-rouge">&amp;T</code>로 변환됩니다.</p>
</blockquote>

<p>예를 들어 <code class="highlighter-rouge">&amp;Rc&lt;String&gt;</code>이 있으면 이 규칙에 따라 <code class="highlighter-rouge">&amp;String</code>으로 변환되며, 이는 다시 같은 방법으로 <code class="highlighter-rouge">&amp;str</code>로 변환됩니다.
따라서 함수가 <code class="highlighter-rouge">&amp;str</code> 인자를 받는다면 <code class="highlighter-rouge">&amp;Rc&lt;String&gt;</code>을 그대로 넘겨 주고 모든 변환 과정이 <code class="highlighter-rouge">Deref</code> 트레이트로 자동으로 처리되도록 할 수 있습니다.</p>

<p>가장 흔한 deref 변환의 종류로는 이런 게 있습니다:</p>

<ul>
  <li><code class="highlighter-rouge">&amp;Rc&lt;T&gt;</code>를 <code class="highlighter-rouge">&amp;T</code>로</li>
  <li><code class="highlighter-rouge">&amp;Box&lt;T&gt;</code>를 <code class="highlighter-rouge">&amp;T</code>로</li>
  <li><code class="highlighter-rouge">&amp;Arc&lt;T&gt;</code>를 <code class="highlighter-rouge">&amp;T</code>로</li>
  <li><code class="highlighter-rouge">&amp;Vec&lt;T&gt;</code>를 <code class="highlighter-rouge">&amp;[T]</code>로</li>
  <li><code class="highlighter-rouge">&amp;String</code>을 <code class="highlighter-rouge">&amp;str</code>로</li>
</ul>

<h2 id="lifetimes">수명</h2>

<h3><a href="#why-lifetimes" name="why-lifetimes">
수명(lifetime)을 왜 쓰나요?
</a></h3>

<p>수명은 메모리 안전성에 대한 Rust의 해답입니다.
Rust는 수명을 사용해서 쓰레기 수거(garbage collection)의 성능 비용 없이 메모리 안전성을 보장합니다.
수명 개념은 다양한 학술 연구에 기반해 있으며, 《<a href="https://doc.rust-lang.org/stable/book/bibliography.html#type-system">Rust 프로그래밍 언어</a>》에서 참조를 확인할 수 있습니다.</p>

<h3><a href="#why-is-the-lifetime-syntax-the-way-it-is" name="why-is-the-lifetime-syntax-the-way-it-is">
왜 수명 문법이 지금과 같은가요?
</a></h3>

<p><code class="highlighter-rouge">'a</code> 문법은 ML 계열의 프로그래밍 언어에서 따 왔는데, 여기서 <code class="highlighter-rouge">'a</code> 문법은 일반화된 타입 인자를 나타내는 데 사용됩니다.
Rust의 경우 수명 문법은 모호하지 않고, 눈에 띄어야 했으며 타입 선언에서 트레이트와 참조와 함께 쓰기 좋아야 했습니다.
다른 문법도 의논되었으나 이보다 확실히 더 좋은 문법이 제시되진 않았습니다.</p>

<h3><a href="#how-do-i-return-a-borrow-to-something-i-created-from-a-function" name="how-do-i-return-a-borrow-to-something-i-created-from-a-function">
함수 안에서 만든 무언가를 빌려서 반환하려면 어떻게 하나요?
</a></h3>

<p>빌린 물건이 함수보다 더 오래 살아 남는다는 걸 보장해야 합니다.
이는 다음과 같이 출력 수명을 입력 수명에 매어 놓아서 가능합니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">type</span> <span class="n">Pool</span> <span class="o">=</span> <span class="n">TypedArena</span><span class="o">&lt;</span><span class="n">Thing</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c">// (아래 수명 표시는 설명을 위해서 명시적으로 쓰인 것뿐이며,</span>
<span class="c">// 뒤의 질문에서 설명하는 탈락(eilsion) 규칙에 따라</span>
<span class="c">// 생략할 수 있습니다)</span>
<span class="k">fn</span> <span class="n">create_borrowed</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pool</span><span class="p">:</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">a</span> <span class="n">Pool</span><span class="p">,</span>
                       <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
                       <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">a</span> <span class="n">Thing</span> <span class="p">{</span>
    <span class="n">pool</span><span class="nf">.alloc</span><span class="p">(</span><span class="n">Thing</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="p">})</span>
<span class="p">}</span>
</code></pre>
</div>

<p>또는 <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a> 같이 소유하는 타입들을 반환해서 참조를 아예 없애는 대안도 있습니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">happy_birthday</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="nb">i64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"Hello {}! You're {} years old!"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>이 접근은 더 간단하지만 종종 불필요한 할당이 일어납니다.</p>

<h3><a href="#when-are-lifetimes-required-to-be-explicit" name="when-are-lifetimes-required-to-be-explicit">
왜 어떤 참조에는 <code>&amp;'a T</code>같이 수명이 있고 다른 참조에는 <code>&amp;T</code>같이 없는 건가요?
</a></h3>

<p>사실 <em>모든</em> 참조 타입에는 수명이 있지만, 대부분의 경우 직접 쓸 필요가 없습니다.
규칙은 다음과 같습니다:</p>

<ol>
  <li>함수 몸체에서는 수명을 명시적으로 쓸 필요가 전혀 없으며 항상 올바른 값이 추론될 것입니다.</li>
  <li>함수 <em>서명</em> (예를 들어 인자 타입이나 반환 타입) 안에서는 수명을 명시적으로 써야 할 수<em>도</em> 있습니다.
여기에서는 <a href="https://doc.rust-lang.org/book/lifetimes.html#lifetime-elision">“수명 탈락(elision)”</a>이라는 간단한 기본값이 적용되는데 이는 다음 세 규칙으로 구성되어 있습니다:
    <ul>
      <li>인자에서 탈락된 각 수명은 서로 다른 인자가 됩니다.</li>
      <li>입력 수명이 하나 뿐이면, 그게 탈락되었든 아니든 그 함수의 반환 값에 있는 모든 탈락된 수명에 할당됩니다.</li>
      <li>입력 수명이 여럿 있지만 그 중 하나가 &amp;self거나 &amp;mut self라면, self의 수명이 모든 탈락된 출력 수명에 할당됩니다.</li>
    </ul>
  </li>
  <li>마지막으로 <code class="highlighter-rouge">struct</code>와 <code class="highlighter-rouge">enum</code> 정의에서는 모든 수명이 명시적으로 선언되어야 합니다.</li>
</ol>

<p>만약 이 규칙이 컴파일 오류를 일으킨다면, Rust 컴파일러는 일어난 오류를 가리키는 오류 메시지를 제공하면서 그 오류가 일어난 추론 단계에 따라 가능한 수정을 제시할 것입니다.</p>

<h3><a href="#how-can-rust-guarantee-no-null-pointers" name="how-can-rust-guarantee-no-null-pointers">
Rust는 어떻게 "널 포인터가 없다"는 것과 "유령 포인터(dangling pointer)가 없다"는 것을 보장하나요?
</a></h3>

<p><code class="highlighter-rouge">&amp;Foo</code>와 <code class="highlighter-rouge">&amp;mut Foo</code> 타입의 값을 만드는 유일한 방법은 이미 존재하는 <code class="highlighter-rouge">Foo</code> 타입의 값을 참조가 가리키는 값으로 명시하는 것 뿐입니다.
참조는 주어진 코드 영역(즉, 참조의 수명) 안에서 원래 값을 “빌리며”, 참조가 값을 빌린 동안에는 원래 값을 옮기거나 소멸시킬 수 없습니다.</p>

<h3><a href="#how-do-i-express-the-absense-of-a-value-without-null" name="how-do-i-express-the-absense-of-a-value-without-null">
<code>null</code> 없이 값이 없다는 걸 어떻게 표현하나요?
</a></h3>

<p><a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code class="highlighter-rouge">Option</code></a> 타입을 씁니다.
이 타입은 <code class="highlighter-rouge">Some(T)</code>이거나 <code class="highlighter-rouge">None</code>일 수 있는데, <code class="highlighter-rouge">Some(T)</code>은 <code class="highlighter-rouge">T</code> 타입의 값이 들어 있다는 걸 나타내고, <code class="highlighter-rouge">None</code>은 값이 없다는 걸 나타냅니다.</p>

<h2 id="generics">일반화 (제너릭)</h2>

<h3><a href="#what-is-monomorphisation" name="what-is-monomorphisation">
"단형화"(monomorphisation)가 무엇인가요?
</a></h3>

<p>단형화는 일반화된 함수(나 구조체)의 각 사용을, 함수를 호출하는 데 쓰인 인자 타입(이나 구조체의 용례)에 따라 각 인스턴스로 특수화합니다.</p>

<p>단형화 과정에서는 함수가 인스턴스화된 타입의 집합 하나 하나마다 일반화된 함수의 새 사본이 번역됩니다.
이는 C++가 사용하는 전략과 같습니다.
모든 함수 호출에 대해 특수화되고 정적으로 디스패치되는 빠른 코드가 만들어지지만, 서로 다른 타입에 대해 인스턴스된 함수는 “코드 팽창”을 일으켜 다른 번역 전략에 비해 더 큰 바이너리를 생성해낼 수 있다는 트레이드오프가 있습니다.</p>

<p>타입 인자 대신 <a href="https://doc.rust-lang.org/book/trait-objects.html">트레이트 객체</a>를 받는 함수들은 단형화를 거치지 않습니다.
대신 트레이트 객체의 함수들은 실행 시간에 동적으로 디스패치됩니다.</p>

<h3><a href="#whats-the-difference-between-a-function-and-a-closure-that-doesnt-capture" name="whats-the-difference-between-a-function-and-a-closure-that-doesnt-capture">
함수와 아무 변수도 갈무리하지 않는 클로저 사이에 어떤 차이가 있나요?
</a></h3>

<p>함수와 클로저는 동작상으로는 동일하지만, 구현이 다르기 때문에 실행 시간에는 다른 표현을 가집니다.</p>

<p>함수는 언어에 내장된 원시 타입이며, 클로저는 근본적으로 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Fn.html"><code class="highlighter-rouge">Fn</code></a>, <a href="https://doc.rust-lang.org/stable/std/ops/trait.FnMut.html"><code class="highlighter-rouge">FnMut</code></a>, 그리고 <a href="https://doc.rust-lang.org/stable/std/ops/trait.FnOnce.html"><code class="highlighter-rouge">FnOnce</code></a> 세 트레이트에 대한 문법 설탕입니다.
클로저를 만들 때 Rust 컴파일러는 자동으로 이들 세 트레이트 중 적절한 것들을 구현하고, 갈무리된 환경의 변수들을 멤버로 가지는 구조체를 만들어 함수로 불릴 수 있도록 합니다.
벌거벗은(bare) 함수는 환경을 갈무리할 수 없습니다.</p>

<p>이들 트레이트 사이의 큰 차이는 <code class="highlighter-rouge">self</code> 인자를 받는 방법에 있습니다.
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Fn.html"><code class="highlighter-rouge">Fn</code></a>은 <code class="highlighter-rouge">&amp;self</code>를, <a href="https://doc.rust-lang.org/stable/std/ops/trait.FnMut.html"><code class="highlighter-rouge">FnMut</code></a>은 <code class="highlighter-rouge">&amp;mut self</code>를, 그리고 <a href="https://doc.rust-lang.org/stable/std/ops/trait.FnOnce.html"><code class="highlighter-rouge">FnOnce</code></a>는 <code class="highlighter-rouge">self</code>를 받습니다.</p>

<p>클로저가 환경에서 아무 변수도 갈무리하지 않는다 하여도, 다른 클로저와 마찬가지로 실행 시간에는 두 개의 포인터로 표현됩니다.</p>

<h3><a href="#what-are-higher-kinded-types" name="what-are-higher-kinded-types">
상류(higher-kinded) 타입이 무엇인가요? 그게 어째서 필요하다는 건가요? Rust에 상류 타입이 없는 이유는 무엇인가요?
<!-- 역주: higher-order 고차, higher-rank 상위, higher-kind 상류. -->
</a></h3>

<p>상류 타입은 인자가 채워져 있지 않은 타입입니다.
<a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec</code></a>, <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a>나 <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code class="highlighter-rouge">HashMap</code></a> 같은 타입 생성자는 모두 상류 타입의 예로, 각각 특정한 타입을 가리키려면 <code class="highlighter-rouge">Vec&lt;u32&gt;</code>와 같이 추가로 타입 인자가 필요합니다.
상류 타입을 지원한다는 얘기는 “완전한” 타입들이 쓰일 수 있는 곳 어디에나, 이를테면 일반화된 함수 같은 곳에서 “불완전한” 타입도 쓸 수 있다는 뜻입니다.</p>

<p><a href="https://doc.rust-lang.org/stable/std/primitive.i32.html"><code class="highlighter-rouge">i32</code></a>, <a href="https://doc.rust-lang.org/stable/std/primitive.bool.html"><code class="highlighter-rouge">bool</code></a>이나 <a href="https://doc.rust-lang.org/stable/std/primitive.char.html"><code class="highlighter-rouge">char</code></a> 같은 완전한 타입은 종류(kind)가 <code class="highlighter-rouge">*</code>입니다(이 표기법은 타입 이론에서 유래합니다).
<a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec&lt;T&gt;</code></a> 같이 인자가 하나인 타입은 종류가 <code class="highlighter-rouge">* -&gt; *</code>이며, 이는 이를테면 <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec&lt;T&gt;</code></a>은 <a href="https://doc.rust-lang.org/stable/std/primitive.i32.html"><code class="highlighter-rouge">i32</code></a> 같은 완전한 타입을 받아서 <code class="highlighter-rouge">Vec&lt;i32&gt;</code> 같은 완전한 타입을 반환한다는 뜻입니다.
<a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code class="highlighter-rouge">HashMap&lt;K, V, S&gt;</code></a> 같이 인자가 세 개인 타입은 종류가 <code class="highlighter-rouge">* -&gt; * -&gt; * -&gt; *</code>이며, 세 개의 완전한 타입(<a href="https://doc.rust-lang.org/stable/std/primitive.i32.html"><code class="highlighter-rouge">i32</code></a>, <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/hash_map/struct.RandomState.html"><code class="highlighter-rouge">RandomState</code></a> 같이)을 받아서 새로운 완전한 타입 <code class="highlighter-rouge">HashMap&lt;i32, String, RandomState&gt;</code>를 만들어 냅니다.</p>

<p>위 예제에 덧붙여 타입 생성자는 <em>수명</em> 인자도 받을 수 있는데 여기서는 <code class="highlighter-rouge">Lt</code>라고 표기하겠습니다.
예를 들어 <code class="highlighter-rouge">slice::Iter</code>는 종류가 <code class="highlighter-rouge">Lt -&gt; * -&gt; *</code>인데, <code class="highlighter-rouge">Iter&lt;'a, u32&gt;</code> 처럼 인스턴스화되어야 하기 때문입니다.</p>

<p>상류 타입 지원이 없으면 특정한 종류의 일반화된 코드를 짜기 어렵습니다.
특히 흔히 수명 등으로 종종 매개변수화되는 반복자 같은 개념을 추상화하는 데 문제가 생깁니다.
이것 때문에 Rust의 컬렉션을 추상화하는 트레이트는 그간 만들 수 없었습니다.</p>

<p>또 다른 흔한 예제로는 함수자(functor)나 모나드(monad) 같은 개념으로, 둘 다 하나의 타입이 아닌 타입 생성자입니다.</p>

<p>Rust는 현재 상류 타입을 지원하지 않는데 저희가 하고자 하는 다른 개선점보다 우선순위가 낮았기 때문입니다.
이 설계는 대규모로 많은 곳들에 영향을 미치기 때문에 주의깊게 접근하고 싶은 것도 있습니다.
하지만 현재 상류 타입을 지원하지 않는 데는 다른 특별한 이유가 있는 건 아닙니다.</p>

<h3><a href="#what-do-named-type-parameters-in-generic-types-mean" name="what-do-named-type-parameters-in-generic-types-mean">
일반화 타입에 <code>&lt;T=Foo&gt;</code> 같은 이름이 붙은 타입 인자는 무엇인가요?
</a></h3>

<p>이들은 <a href="https://doc.rust-lang.org/stable/book/associated-types.html">연관 타입(associated type)</a>이라 하며, <code class="highlighter-rouge">where</code> 절로 표현할 수 없는 트레이트 제약을 가능케 합니다.
예를 들어 일반화된 제약 <code class="highlighter-rouge">X: Bar&lt;T=Foo&gt;</code>는 “<code class="highlighter-rouge">X</code>는 <code class="highlighter-rouge">Bar</code> 트레이트를 구현해야 하고, 그 <code class="highlighter-rouge">Bar</code>의 구현에서 <code class="highlighter-rouge">X</code>는 <code class="highlighter-rouge">Bar</code>의 연관 타입 <code class="highlighter-rouge">T</code>로 <code class="highlighter-rouge">Foo</code>를 선택해야 한다”는 뜻입니다.
<code class="highlighter-rouge">where</code> 절만으로 표현할 수 없는 제약의 예제로는 <code class="highlighter-rouge">Box&lt;Bar&lt;T=Foo&gt;&gt;</code> 같은 트레이트 객체가 있습니다.</p>

<p>연관 타입은, 일반화 과정에서 타입의 무리가 존재해 한 타입 인자가 무리의 모든 타입을 결정하는 경우가 종종 있기 때문에 존재합니다.
예를 들어 그래프 트레이트는 그래프 자신을 가리키는 <code class="highlighter-rouge">Self</code> 타입을 가질 수 있고, 정점과 간선을 위한 연관 타입을 가질 수 있습니다.
각 그래프 타입은 연관 타입들을 유일하게 결정합니다.
연관 타입은 이러한 타입의 무리를 다루는 걸 훨씬 간명하게 만들고, 많은 경우 타입 추론에도 도움이 됩니다.</p>

<h3><a href="#how-do-i-overload-operators" name="how-do-i-overload-operators">
연산자를 오버로드할 수 있나요? 어떤 게 가능하고 어떻게 하나요?
</a></h3>

<p>대응되는 트레이트를 구현해서 여러 연산자들에 원하는 구현을 제공할 수 있습니다. <code class="highlighter-rouge">+</code>라면 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html"><code class="highlighter-rouge">Add</code></a>, <code class="highlighter-rouge">*</code>라면 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Mul.html"><code class="highlighter-rouge">Mul</code></a> 등등이 있습니다. 이런 식으로 씁니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nb">Add</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Foo</span><span class="p">;</span>

<span class="k">impl</span> <span class="nb">Add</span> <span class="k">for</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Foo</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Adding!"</span><span class="p">);</span>
        <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>다음 연산자들을 오버로드할 수 있습니다:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">연산자</th>
      <th style="text-align: left">트레이트</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">+</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html"><code class="highlighter-rouge">Add</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">+=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.AddAssign.html"><code class="highlighter-rouge">AddAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">이항 -</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Sub.html"><code class="highlighter-rouge">Sub</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">-=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.SubAssign.html"><code class="highlighter-rouge">SubAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">*</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Mul.html"><code class="highlighter-rouge">Mul</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">*=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.MulAssign.html"><code class="highlighter-rouge">MulAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">/</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Div.html"><code class="highlighter-rouge">Div</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">/=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.DivAssign.html"><code class="highlighter-rouge">DivAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">단항 -</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Neg.html"><code class="highlighter-rouge">Neg</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">%</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Rem.html"><code class="highlighter-rouge">Rem</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">%=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.RemAssign.html"><code class="highlighter-rouge">RemAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">&amp;</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.BitAnd.html"><code class="highlighter-rouge">BitAnd</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code>&#124;</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.BitOr.html"><code class="highlighter-rouge">BitOr</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code>&#124;</code>=</td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.BitOrAssign.html"><code class="highlighter-rouge">BitOrAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">^</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.BitXor.html"><code class="highlighter-rouge">BitXor</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">^=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.BitXorAssign.html"><code class="highlighter-rouge">BitXorAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">!</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Not.html"><code class="highlighter-rouge">Not</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;&lt;</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Shl.html"><code class="highlighter-rouge">Shl</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;&lt;=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.ShlAssign.html"><code class="highlighter-rouge">ShlAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">&gt;&gt;</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Shr.html"><code class="highlighter-rouge">Shr</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">&gt;&gt;=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.ShrAssign.html"><code class="highlighter-rouge">ShrAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">*</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Deref.html"><code class="highlighter-rouge">Deref</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">mut *</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code class="highlighter-rouge">DerefMut</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">[]</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Index.html"><code class="highlighter-rouge">Index</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">mut []</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.IndexMut.html"><code class="highlighter-rouge">IndexMut</code></a></td>
    </tr>
  </tbody>
</table>

<h3><a href="#why-the-split-between-eq-partialeq-and-ord-partialord" name="why-the-split-between-eq-partialeq-and-ord-partialord">
<code>Eq</code>/<code>PartialEq</code>와 <code>Ord</code>/<code>PartialOrd</code>가 나뉜 이유는 무엇인가요?
</a></h3>

<p>Rust의 몇몇 타입들은 그 값들이 부분적으로만 순서가 있거나, 부분적으로만 등치 관계입니다.
부분 순서(partial ordering)란 주어진 타입의 어떤 값들이 서로 작지도 크지도 않을 수 있다는 뜻입니다.
부분 등치(partial equality)란 주어진 타입의 어떤 값들이 자기 자신과 같지 않을 수 있다는 뜻입니다.</p>

<p>부동 소숫점 타입들(<a href="https://doc.rust-lang.org/stable/std/primitive.f32.html"><code class="highlighter-rouge">f32</code></a>와 <a href="https://doc.rust-lang.org/stable/std/primitive.f64.html"><code class="highlighter-rouge">f64</code></a>)이 좋은 예제입니다.
모든 부동 소숫점 타입에는 <code class="highlighter-rouge">NaN</code>(“not a number”, 즉 “숫자가 아님”을 뜻함) 값이 있습니다.
<code class="highlighter-rouge">NaN</code>은 자기 자신과 같지도 않고(<code class="highlighter-rouge">NaN == NaN</code>은 거짓입니다), 다른 부동 소숫점 값보다 작지도 크지도 않습니다.
따라서 <a href="https://doc.rust-lang.org/stable/std/primitive.f32.html"><code class="highlighter-rouge">f32</code></a>와 <a href="https://doc.rust-lang.org/stable/std/primitive.f64.html"><code class="highlighter-rouge">f64</code></a>는 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialOrd.html"><code class="highlighter-rouge">PartialOrd</code></a>와 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialEq.html"><code class="highlighter-rouge">PartialEq</code></a>를 구현하지만 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code class="highlighter-rouge">Ord</code></a>와 <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Eq.html"><code class="highlighter-rouge">Eq</code></a>는 구현하지 않습니다.</p>

<p><a href="#why-cant-i-compare-floats">부동 소숫점에 대한 이전 질문</a>에서 설명되었듯, 이러한 구분은 몇몇 컬렉션이 올바른 결과를 내는데 전순서/전등치에 의존하기 때문에 중요합니다.</p>

<h2 id="input-output">입출력</h2>

<h3><a href="#how-do-i-read-a-file-into-a-string" name="how-do-i-read-a-file-into-a-string">
파일을 <code>String</code>으로 읽으려면 어떻게 하나요?
</a></h3>

<p><a href="https://doc.rust-lang.org/stable/std/io/index.html"><code class="highlighter-rouge">std::io</code></a>의 <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html"><code class="highlighter-rouge">Read</code></a> 트레이트에 있는 <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.read_to_string"><code class="highlighter-rouge">read_to_string()</code></a> 메소드를 씁니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Read</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="nd">try!</span><span class="p">(</span><span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nd">try!</span><span class="p">(</span><span class="n">f</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">));</span>  <span class="c">// `s`는 "foo.txt"의 내용을 담습니다</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">match</span> <span class="nf">read_file</span><span class="p">(</span><span class="s">"foo.txt"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Got file contents!"</span><span class="p">),</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Getting file contents failed with error: {}"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre>
</div>

<h3><a href="#how-do-i-read-file-input-efficiently" name="how-do-i-read-file-input-efficiently">
파일을 효율적으로 읽으려면 어떻게 하나요?
</a></h3>

<p><a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html"><code class="highlighter-rouge">File</code></a> 타입은 <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html"><code class="highlighter-rouge">Read</code></a> 트레이트를 구현하며, 여기에는 데이터를 읽고 쓰는 다양한 함수들이 존재하는데 <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#tymethod.read"><code class="highlighter-rouge">read()</code></a>, <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.read_to_end"><code class="highlighter-rouge">read_to_end()</code></a>, <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.bytes"><code class="highlighter-rouge">bytes()</code></a>, <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.chars"><code class="highlighter-rouge">chars()</code></a>, 그리고 <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.take"><code class="highlighter-rouge">take()</code></a> 등이 포함됩니다.
각 함수들은 주어진 파일로부터 일정한 만큼의 입력을 읽어 들입니다.
<a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#tymethod.read"><code class="highlighter-rouge">read()</code></a>는 기반 시스템이 한 번의 호출에서 제공하는 한 최대한 많은 입력을 읽어 들입니다.
<a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.read_to_end"><code class="highlighter-rouge">read_to_end()</code></a>는 전체 버퍼를 벡터로 읽어 들이고, 필요에 따라 공간을 할당합니다.
<a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.bytes"><code class="highlighter-rouge">bytes()</code></a>와 <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.chars"><code class="highlighter-rouge">chars()</code></a>는 파일 안의 바이트와 문자에 대해 반복을 수행합니다.
마지막으로 <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.take"><code class="highlighter-rouge">take()</code></a>로 파일로부터 최대 지정한 만큼의 바이트를 읽을 수 있습니다.
이들 함수들로 필요한 어떤 데이터라도 효율적으로 읽어 들일 수 있습니다.</p>

<p>버퍼를 통해서 읽고 싶다면 <a href="https://doc.rust-lang.org/stable/std/io/struct.BufReader.html"><code class="highlighter-rouge">BufReader</code></a> 구조체를 사용하세요.
이 구조체는 읽는 과정에서 시스템 호출의 숫자를 줄이는 데 도움이 됩니다.</p>

<h3><a href="#how-do-i-do-asynchronous-input-output-in-rust" name="how-do-i-do-asynchronous-input-output-in-rust">
Rust에서 어떻게 비동기 입출력을 하나요?
</a></h3>

<p>Rust에서 비동기 입출력을 제공하는 라이브러리로는 <a href="https://github.com/carllerche/mio">mio</a>, <a href="https://github.com/tokio-rs/tokio-core">tokio</a>, <a href="https://github.com/dpc/mioco">mioco</a>, <a href="https://github.com/zonyitoo/coio-rs">coio-rs</a>, 그리고 <a href="https://github.com/tailhook/rotor">rotor</a> 등이 있습니다.</p>

<h3><a href="#how-do-i-get-command-line-arguments" name="how-do-i-get-command-line-arguments">
Rust에서 명령행 인자를 받는 방법은 무엇인가요?
</a></h3>

<p>가장 쉬운 방법은 <a href="https://doc.rust-lang.org/stable/std/env/struct.Args.html"><code class="highlighter-rouge">Args</code></a>를 써서 입력 인자들에 대한 반복자를 받는 것입니다.</p>

<p>더 강력한 무언가를 찾고 있다면 <a href="https://crates.io/keywords/argument">crates.io에 여러 선택이 있습니다</a>.</p>

<h2 id="error-handling">오류 처리</h2>

<h3><a href="#why-doesnt-rust-have-exceptions" name="why-doesnt-rust-have-exceptions">
Rust에는 왜 예외(exception)가 없나요?
</a></h3>

<p>예외는 제어 흐름을 이해하기 복잡하게 만들고, 타입 시스템을 넘어서는 유효성/무효성을 표현하며, (Rust의 주요 촛점인) 멀티스레딩된 코드와 잘 상호작용하지 않습니다.</p>

<p>Rust는 오류 처리에 타입 기반의 접근을 선호하며, <a href="https://doc.rust-lang.org/stable/book/error-handling.html">《Rust 프로그래밍 언어》에서 길게 다루고 있습니다</a>.
이는 Rust의 제어 흐름, 동시성 및 여타 다른 것들에 더 잘 맞아 들어 갑니다.</p>

<h3><a href="#whats-the-deal-with-unwrap" name="whats-the-deal-with-unwrap">
여기 저기 보이는 <code>unwrap()</code>를 어떻게 할 수 없나요?
</a></h3>

<p><code class="highlighter-rouge">unwrap()</code>은 <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code class="highlighter-rouge">Option</code></a>이나 <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a> 안에 있는 값을 뽑아 내고 아무 값도 없으면 패닉을 일으키는 함수입니다.</p>

<p><code class="highlighter-rouge">unwrap()</code>이 잘못된 사용자 입력 같이 예상할 수 있는 오류들을 기본으로 다루는 방법이 되어서는 안 됩니다.
현업 코드에서 이는 값이 비어 있지 않으며 만에 하나 비어 있다면 프로그램이 깨지는 단언(assertion)처럼 취급되어야 합니다.</p>

<p>또한 <code class="highlighter-rouge">unwrap()</code>은 아직 오류를 처리하고 싶지 않은 빠른 프로토타입이나, 오류 처리가 주요 논점을 흐릴 수 있는 블로그 글에서도 유용합니다.</p>

<h3><a href="#why-do-i-get-errors-with-try" name="why-do-i-get-errors-with-try">
<code>try!</code> 매크로를 쓰는 예제 코드를 실행하려고 할 때 오류가 나는 이유는 뭔가요?
</a></h3>

<p>아마도 함수의 반환 타입에 문제가 있을 겁니다.
<a href="https://doc.rust-lang.org/stable/std/macro.try!.html"><code class="highlighter-rouge">try!</code></a> 매크로는 <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a>에서 값을 뽑아 내거나, <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a>가 들고 있는 오류를 먼저 반환합니다.
즉 <a href="https://doc.rust-lang.org/stable/std/macro.try!.html"><code class="highlighter-rouge">try</code></a>는 <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a>를 반환하는 함수에서만 동작하며, 이 때 <code class="highlighter-rouge">Err</code>로 만들어지는 타입은 <code class="highlighter-rouge">From::from(err)</code>을 구현해야 합니다.
특히 이는 <code class="highlighter-rouge">main</code> 함수에서는 <a href="https://doc.rust-lang.org/stable/std/macro.try!.html"><code class="highlighter-rouge">try!</code></a> 매크로를 쓸 수 없다는 뜻이기도 합니다.</p>

<h3><a href="#error-handling-without-result" name="error-handling-without-result">
모든 곳에 <code>Result</code>를 쓰는 것 말고 더 쉽게 오류를 처리할 방법이 없나요?
</a></h3>

<p>다른 사람의 코드에 있는 <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a>를 처리하지 않는 방법을 원한다면 항상 <a href="https://doc.rust-lang.org/stable/core/option/enum.Option.html#method.unwrap"><code class="highlighter-rouge">unwrap()</code></a>를 쓸 수 있지만, 아마도 원하는 게 아닐 겁니다.
<a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a>는 어떤 계산이 성공적으로 끝나거나 끝나지 않을 수 있다는 표시입니다.
이러한 실패를 처리하도록 요구하는 건 Rust가 튼튼한 코드를 권장하는 방법 중 하나입니다.
Rust는 실패를 더 편리하게 처리할 수 있도록 <a href="https://doc.rust-lang.org/stable/std/macro.try!.html"><code class="highlighter-rouge">try!</code> 매크로</a> 같은 도구를 제공합니다.</p>

<p>정말로 오류를 처리하고 싶지 않다면 <a href="https://doc.rust-lang.org/stable/core/option/enum.Option.html#method.unwrap"><code class="highlighter-rouge">unwrap()</code></a>를 쓰세요.
하지만 이렇게 하면 실패시 코드가 패닉을 일으키고, 보통 이는 프로세스를 종료시킨다는 점을 유의하시길 바랍니다.</p>

<h2 id="concurrency">동시성</h2>

<h3><a href="#can-i-use-static-values-across-threads-without-an-unsafe-block" name="can-i-use-static-values-across-threads-without-an-unsafe-block">
<code>unsafe</code> 블록 없이 여러 스레드에서 정적인 값을 사용할 수는 없을까요?
</a></h3>

<p>변경은 동기화가 된다면 안전합니다.
(<a href="https://crates.io/crates/lazy_static/">lazy-static</a> 크레이트로 지연되어 초기화된) 정적인 <a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html"><code class="highlighter-rouge">Mutex</code></a>를 변경하는 데는 <code class="highlighter-rouge">unsafe</code> 블록이 필요 없으며, 정적인 <a href="https://doc.rust-lang.org/stable/std/sync/atomic/struct.AtomicUsize.html"><code class="highlighter-rouge">AtomicUsize</code></a>를 변경하는 데도 필요 없습니다(이건 lazy_static 없이 초기화할 수 있습니다).</p>

<p>좀 더 일반적으로, 타입이 <a href="https://doc.rust-lang.org/stable/std/marker/trait.Sync.html"><code class="highlighter-rouge">Sync</code></a>를 구현하고 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Drop.html"><code class="highlighter-rouge">Drop</code></a>을 구현하지 않는다면 <a href="https://doc.rust-lang.org/book/const-and-static.html#static"><code class="highlighter-rouge">static</code>에서 사용할 수 있습니다</a>.</p>

<h2 id="macros">매크로</h2>

<h3><a href="#can-i-write-a-macro-to-generate-identifiers" name="can-i-write-a-macro-to-generate-identifiers">
식별자를 생성하는 매크로를 짤 수 있나요?
</a></h3>

<p>현재는 안 됩니다.
Rust 매크로는 <a href="https://en.wikipedia.org/wiki/Hygienic_macro">“위생적인(hygienic) 매크로”</a>로, 예상치 못 하게 다른 식별와 겹치는 식별자를 갈무리하거나 만드는 걸 피합니다.
이런 매크로의 능력은 C 전처리기에서 흔히 쓰이는 스타일의 매크로와는 상당히 다릅니다.
매크로 호출은 명시적으로 지원되는 곳, 즉 아이템, 메소드 선언, 문장, 수식 및 패턴에서만 나타날 수 있습니다.
여기서 “메소드 선언”이란 메소드를 집어 넣을 수 있는 빈 공간을 말합니다.
이들은 부분적인 메소드 선언을 채우는 데 쓰일 수는 없습니다.
같은 논리로, 이들은 부분적인 변수 선언을 채우는 데 쓰일 수 없습니다.</p>

<h2 id="debugging">디버깅 및 도구</h2>

<h3><a href="#how-do-i-debug-rust-programs" name="how-do-i-debug-rust-programs">
Rust 프로그램은 어떻게 디버깅하나요?
</a></h3>

<p>Rust 프로그램은 C나 C++와 같이 <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">gdb</a>나 <a href="http://lldb.llvm.org/tutorial.html">lldb</a>로 디버깅할 수 있습니다.
사실은 모든 Rust 설치에는 (플랫폼 지원에 따라) rust-gdb나 rust-lldb 둘 중 하나가 함께 들어 있습니다.
이들은 gdb와 lldb에 Rust 값을 보기 좋게 출력해 주도록 감싼 것입니다.</p>

<h3><a href="#how-do-i-locate-a-panic" name="how-do-i-locate-a-panic">
<code>rustc</code>가 표준 라이브러리 코드에서 패닉(panic)이 일어났다고 하는데, 제 코드의 실수를 어떻게 찾을 수 있을까요?
</a></h3>

<p>이 오류는 보통 사용자 코드에서 <code class="highlighter-rouge">None</code>이나 <code class="highlighter-rouge">Err</code>을 <a href="https://doc.rust-lang.org/stable/core/option/enum.Option.html#method.unwrap"><code class="highlighter-rouge">unwrap()</code></a>해서 일어납니다.
<code class="highlighter-rouge">RUST_BACKTRACE=1</code> 환경 변수를 설정해서 스택 추적(backtrace)을 켜는 게 더 많은 정보를 얻는데 도움이 됩니다.
디버그 모드로 컴파일하거나(<code class="highlighter-rouge">cargo build</code>의 기본값), 함께 들어 있는 <code class="highlighter-rouge">rust-gdb</code>나 <code class="highlighter-rouge">rust-lldb</code> 같은 디버거를 쓰는 것도 도움이 됩니다.</p>

<h3><a href="#what-ide-should-i-use" name="what-ide-should-i-use">
무슨 IDE를 써야 하나요?
</a></h3>

<p>Rust 개발 환경에는 여러 선택이 있으며 자세한 사항은 공식 <a href="https://forge.rust-lang.org/ides.html">IDE 지원 페이지</a>에 설명되어 있습니다.</p>

<h3><a href="#wheres-rustfmt" name="wheres-rustfmt">
<code>gofmt</code>은 멋져요. <code>rustfmt</code> 같은 건 없나요?
</a></h3>

<p><code class="highlighter-rouge">rustfmt</code>은 <a href="https://github.com/rust-lang-nursery/rustfmt">여기</a> 있고, Rust 코드를 가능한한 읽기 쉽고 예측 가능하게 만들도록 활발히 개발되고 있습니다.</p>

<h2 id="low-level">저수준</h2>

<h3><a href="#how-do-i-memcpy-bytes" name="how-do-i-memcpy-bytes">
<code>memcpy</code>같이 바이트를 복사하려면 어떻게 하나요?
</a></h3>

<p>이미 존재하는 슬라이스를 안전하게 복제하려면 <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.clone_from_slice"><code class="highlighter-rouge">clone_from_slice</code></a>를 쓸 수 있습니다.</p>

<p>서로 겹칠 수 있는 바이트들을 복사하려면 <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">copy</code></a>를 쓰세요.
서로 겹칠 수 없는 바이트들을 복사하려면 <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy_nonoverlapping.html"><code class="highlighter-rouge">copy_nonoverlapping</code></a>을 쓰세요.
이들 함수들은 언어의 안전성 보장을 깨뜨리는 데 쓰일 있기 때문에 <code class="highlighter-rouge">unsafe</code>입니다.
사용에 주의를 기울이세요.</p>

<h3><a href="#does-rust-work-without-the-standard-library" name="does-rust-work-without-the-standard-library">
표준 라이브러리 없이 Rust를 사용하는 건 할 만한가요?
</a></h3>

<p>물론입니다.
Rust 프로그램은 <code class="highlighter-rouge">#![no_std]</code> 속성으로 표준 라이브러리를 불러 들이지 않도록 설정할 수 있습니다.
이 속성이 설정되어도 플랫폼 독립적인 원시 타입만 제공되는 Rust 코어 라이브러리는 여전히 사용할 수 있습니다.
따라서 여기에는 I/O, 동시성, 힙(heap) 할당 같은 건 포함되지 않습니다.</p>

<h3><a href="#can-i-write-an-operating-system-in-rust" name="can-i-write-an-operating-system-in-rust">
Rust로 운영체제를 작성할 수 있나요?
</a></h3>

<p>네! 사실 <a href="http://wiki.osdev.org/Rust">정확히 그걸 하는 프로젝트가 여럿 있습니다</a>.</p>

<h3><a href="#how-can-i-write-endian-independent-values" name="how-can-i-write-endian-independent-values">
<code>i32</code>나 <code>f64</code> 같은 수치형을 빅 엔디안이나 리틀 엔디안 형식으로 파일 및 다른 바이트 스트림에 읽고 쓰려면 어떻게 하나요?
</a></h3>

<p><a href="http://burntsushi.net/rustdoc/byteorder/">byteorder 크레이트</a>가 정확히 그걸 하는 유틸리티이니 살펴 보세요.</p>

<h3><a href="#does-rust-guarantee-data-layout" name="does-rust-guarantee-data-layout">
Rust가 메모리 상에 값이 어떻게 배치될 지가 고정되어 있나요?
</a></h3>

<p>기본적으로는 아닙니다.
일반적으로 <code class="highlighter-rouge">enum</code>과 <code class="highlighter-rouge">struct</code>의 배치는 정의되지 않습니다.
따라서 컴파일러가 패딩을 구분값(discriminant)을 넣는데 재사용하거나, 중첩된 <code class="highlighter-rouge">enum</code>들의 변종(variant)들을 압축하거나, 패딩을 없애기 위해 필드를 재배치하는 등의 잠재적인 최적화를 할 수 있게 됩니다.
데이터를 들고 있지 않은 (“C와 비슷한”) <code class="highlighter-rouge">enum</code>은 정의된 표현을 가지도록 할 수 있습니다.
이러한 <code class="highlighter-rouge">enum</code>은 데이터를 들고 있지 않은 이름들만의 단순 목록이므로 쉽게 구분할 수 있습니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">enum</span> <span class="n">CLike</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">,</span>
    <span class="n">B</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mi">34</span><span class="p">,</span>
    <span class="n">D</span>
<span class="p">}</span>
</code></pre>
</div>

<p>이러한 <code class="highlighter-rouge">enum</code>에 <code class="highlighter-rouge">#[repr(C)]</code> 속성을 적용하면 대응되는 C 코드가 가질 표현과 같은 표현이 되도록 할 수 있습니다.
따라서 FFI 코드에서 C <code class="highlighter-rouge">enum</code>이 쓰일 대부분의 상황에서 Rust <code class="highlighter-rouge">enum</code>을 쓸 수 있습니다.
마찬가지로 <code class="highlighter-rouge">struct</code>에도 이 속성을 적용하면 C <code class="highlighter-rouge">struct</code>가 가질 배치와 같은 배치가 되도록 할 수 있습니다.</p>

<h2 id="cross-platform">다중 플랫폼</h2>

<!--
### How do I build a Windows binary that doesn't display the console window?

TODO: Write this answer.
-->

<!--
### How do I make the console-less binary not crash on panic!?

TODO: Write this answer.
-->

<h3><a href="#how-do-i-express-platform-specific-behavior" name="how-do-i-express-platform-specific-behavior">
Rust에서 플랫폼 의존적인 동작을 표현하는 일반적인 방법은 무엇인가요?
</a></h3>

<p>플랫폼 의존적인 동작은 <code class="highlighter-rouge">target_os</code>나 <code class="highlighter-rouge">target_family</code>, <code class="highlighter-rouge">target_endian</code> 같은 <a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">조건부 컴파일 속성</a>으로 표현할 수 있습니다.</p>

<h3><a href="#can-rust-be-used-for-android-ios-programs" name="can-rust-be-used-for-android-ios-programs">
Rust를 안드로이드 및 iOS 프로그래밍에 쓸 수 있나요?
</a></h3>

<p>네 할 수 있습니다!
이미 Rust를 <a href="https://github.com/tomaka/android-rs-glue">안드로이드</a>와 <a href="https://www.bignerdranch.com/blog/building-an-ios-app-in-rust-part-1/">iOS</a>에서 사용하는 예제가 있습니다.
설정에 조금 시간이 들긴 하지만 Rust는 두 플랫폼에서 모두 잘 동작합니다.</p>

<h3><a href="#can-i-run-my-rust-program-in-a-web-browser" name="can-i-run-my-rust-program-in-a-web-browser">
제 Rust 프로그램을 웹 브라우저에서 실행할 수 있나요?
</a></h3>

<p>아마도요. Rust는 <a href="http://asmjs.org/">asm.js</a>와 <a href="http://webassembly.org/">WebAssembly</a> 모두를 <a href="https://davidmcneil.gitbooks.io/the-rusty-web/">실험적으로 지원</a>합니다.</p>

<h3><a href="#how-do-i-cross-compile-rust" name="how-do-i-cross-compile-rust">
Rust에서 크로스 컴파일은 어떻게 하나요?
</a></h3>

<p>Rust에서는 크로스 컴파일을 할 수 있지만 설치 과정이 <a href="https://github.com/japaric/rust-cross/blob/master/README.md">좀 필요합니다</a>.
모든 Rust 컴파일러는 크로스 컴파일러지만 라이브러리는 해당 플랫폼 용으로 크로스 컴파일될 필요가 있습니다.</p>

<p>Rust는 지원되는 플랫폼에 대해서 <a href="https://static.rust-lang.org/dist/index.html">표준 라이브러리의 사본</a>을 배포하고 있으며, 배포판 페이지의 각 빌드 디렉토리에 있는 <code class="highlighter-rouge">rust-std-*</code> 파일들로 들어 있습니다만, 아직 이걸 자동으로 설치하는 방법은 없습니다.</p>

<h2 id="modules-and-crates">모듈 및 크레이트</h2>

<h3><a href="#what-is-the-relationship-between-a-module-and-a-crate" name="what-is-the-relationship-between-a-module-and-a-crate">
모듈과 크레이트 사이에 어떤 관계가 있나요?
</a></h3>

<ul>
  <li>크레이트는 컴파일 단위로, Rust 컴파일러가 다룰 수 있는 가장 작은 규모의 코드입니다.</li>
  <li>모듈은 크레이트 안에 있는 코드 구조의 (중첩될 수도 있는) 단위입니다.</li>
  <li>크레이트에는 암묵적이고 이름이 없는 최상위 모듈이 포함됩니다.</li>
  <li>재귀 정의는 여러 모듈에 걸쳐 있을 수 있지만 여러 크레이트에는 걸칠 수 없습니다.</li>
</ul>

<h3><a href="#why-cant-the-rust-compiler-find-a-library-im-using" name="why-cant-the-rust-compiler-find-a-library-im-using">
Rust 컴파일러가 제가 <code>use</code>한 라이브러리를 찾지 못 하는 이유는 뭔가요?
</a></h3>

<p>여러 가능한 답이 있습니다만, 흔한 실수로는 <code class="highlighter-rouge">use</code> 속성이 크레이트 최상단에 상대적이라는 걸 깨닫지 못 하는 게 있습니다.
선언을 재작성해서 경로가 프로젝트의 최상단 파일에 선언되었을 때랑 똑같은 경로가 되도록 한 뒤 문제가 해결되는지를 확인해 보세요.</p>

<p>또한 <code class="highlighter-rouge">self</code>와 <code class="highlighter-rouge">super</code>를 써서 <code class="highlighter-rouge">use</code> 경로를 각각 현재 모듈이나 상위 모듈에 상대적으로 만들 수 있습니다.</p>

<p>라이브러리를 <code class="highlighter-rouge">use</code>하는 데 대한 완전한 정보에 대해선 《Rust 프로그래밍 언어》의 <a href="https://doc.rust-lang.org/stable/book/crates-and-modules.html">“크레이트와 모듈”</a> 장을 읽으세요.</p>

<h3><a href="#why-do-i-have-to-declare-modules-with-mod" name="why-do-i-have-to-declare-modules-with-mod">
왜 모듈 파일을 정의하기 위해 크레이트 최상위에 <code>mod</code>를 넣어야 하나요? 그냥 <code>use</code>로 지정하면 안 되나요?
</a></h3>

<p>Rust에서 모듈은 제자리에 선언하거나 다른 파일에서 선언할 수 있습니다.
각각의 예제는 다음과 같습니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">// main.rs에서</span>
<span class="k">mod</span> <span class="n">hello</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"hello!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">hello</span><span class="p">::</span><span class="nf">f</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">// main.rs에서</span>
<span class="k">mod</span> <span class="n">hello</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">hello</span><span class="p">::</span><span class="nf">f</span><span class="p">();</span>
<span class="p">}</span>

<span class="c">// hello.rs에서</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"hello!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>첫 예제에서 모듈은 모듈이 사용되는 곳과 같은 파일에 정의되어 있습니다.
둘째 예제에서 메인 파일의 모듈 선언은 컴파일러에게 <code class="highlighter-rouge">hello.rs</code>나 <code class="highlighter-rouge">hello/mod.rs</code>를 찾아 보고 그 파일을 읽으라고 말해 줍니다.</p>

<p><code class="highlighter-rouge">mod</code>와 <code class="highlighter-rouge">use</code>의 차이를 주목하세요.
<code class="highlighter-rouge">mod</code>는 모듈이 존재한다고 선언하지만, <code class="highlighter-rouge">use</code>는 다른 곳에 선언된 모듈을 참조하여 그 내용물을 현재 모듈의 범위 안에 가져 옵니다.</p>

<h3><a href="#how-do-i-configure-cargo-to-use-a-proxy" name="how-do-i-configure-cargo-to-use-a-proxy">
Cargo가 프록시를 사용하도록 설정하려면 어떻게 하나요?
</a></h3>

<p>Cargo <a href="http://doc.crates.io/config.html">환경설정 문서</a>에 설명되어 있듯, 환경설정 파일의 <code class="highlighter-rouge">[http]</code> 아래에 “proxy” 변수를 설정해서 Cargo가 프록시를 쓰도록 할 수 있습니다.</p>

<h3><a href="#why-cant-the-compile-find-method-implementations" name="why-cant-the-compile-find-method-implementations">
이미 크레이트를 <code>use</code>했는데도 왜 컴파일러가 메소드 구현을 찾지 못 하는 걸까요?
</a></h3>

<p>트레이트에 선언된 메소드라면 명시적으로 트레이트 선언을 들여 와야 합니다.
즉, 트레이트를 구현하는 구조체가 있는 모듈만 들이는 것으로 충분하지 않고, 트레이트 자신도 들여 와야 합니다.</p>

<h3><a href="#why-cant-the-compiler-infer-use-statements" name="why-cant-the-compiler-infer-use-statements">
왜 컴파일러가 <code>use</code> 선언을 자동으로 추론하지 못 하나요?
</a></h3>

<p>가능할 수도 있겠지만 별로 원하는 게 아닐 겁니다.
많은 경우 컴파일러가 단순히 주어진 식별자가 선언된 곳을 찾아 보면서 올바른 모듈을 찾아 들여 내는 것이 가능하겠지만, 일반적으로는 아닐 수 있습니다.
서로 겨루는 선택지가 여럿 있다면 <code class="highlighter-rouge">rustc</code>에서 어떤 식으로 결정을 하든 일부 경우에 놀라움과 혼란을 가져올 것이고, Rust는 이름이 어디에서 오는지를 명시적으로 쓰길 선호합니다.</p>

<p>예를 들어 컴파일러가 서로 겨루는 식별자 선언들 중 먼저 들여 온 모듈에서 나온 선언을 선택한다고 칩시다.
그러니까 만약 모듈 <code class="highlighter-rouge">foo</code>와 모듈 <code class="highlighter-rouge">bar</code>가 둘 다 식별자 <code class="highlighter-rouge">baz</code>를 정의하고, <code class="highlighter-rouge">foo</code>가 먼저 등록된 모듈이라면, 컴파일러는 <code class="highlighter-rouge">use foo::baz;</code>를 삽입하게 됩니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">mod</span> <span class="n">foo</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">bar</span><span class="p">;</span>

<span class="c">// use foo::baz  // 이걸 컴파일러가 삽입합니다.</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">baz</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>이게 일어난다는 걸 알고 있다면 아마도 몇 글자 절약이 되기는 하겠지만, <code class="highlighter-rouge">baz()</code>가 사실 <code class="highlighter-rouge">bar::baz()</code>이 되길 원했다면 예기치 않은 오류 메시지가 나올 가능성이 크게 올라가며, 함수 호출의 의미가 모듈 선언에 의존하므로 코드의 가독성이 떨어집니다.
이는 우리가 원하는 트레이드오프가 아닙니다.</p>

<p>다만, 미래에는 IDE가 선언들을 다루는 걸 도와줄 수 있으며 그럼 두 접근의 장점을 모두 얻게 될 겁니다.
기계가 이름을 가져 오는 걸 돕지만 그 이름이 어디서 오는지는 명시적인 선언을 쓰는 거죠.</p>

<!--
### How do I package and archive crates from [https://crates.io](https://crates.io)?

TODO: Write this answer.
-->

<h3><a href="#how-do-i-do-dynamic-rust-library-loading" name="how-do-i-do-dynamic-rust-library-loading">
Rust 라이브러리를 어떻게 동적으로 읽어 들이나요?
</a></h3>

<p>여러 플랫폼에서 동적 링크를 제공하는 <a href="https://crates.io/crates/libloading">libloading</a>으로 동적 라이브러리를 불러 들이세요.</p>

<h3><a href="#why-doesnt-crates-io-have-namespaces" name="why-doesnt-crates-io-have-namespaces">
왜 crates.io에는 이름 공간이 없나요?
</a></h3>

<p><a href="https://crates.io">https://crates.io</a>의 설계에 대한 <a href="https://internals.rust-lang.org/t/crates-io-package-policies/1041">공식 설명</a>을 전재하자면:</p>

<blockquote>
  <p>crates.io의 첫 한 달동안 여러 분들께서 저희들에게 <a href="https://github.com/rust-lang/crates.io/issues/58">패키지 이름 공간</a>을 도입할 가능성에 대해 질문을 해 왔습니다.<br /><br /></p>

  <p>패키지 이름 공간은 여러 저자들이 하나의 일반적인 이름을 쓸 수 있게 하지만, 패키지가 Rust 코드에서 참조되는 방법과 패키지에 대한 사람들 사이의 소통에 복잡도를 더합니다.
얼핏 보면 여러 저자들이 <code class="highlighter-rouge">http</code> 같은 이름을 쓸 수 있을 것 같지만, 실은 이는 사람들이 이 패키지들을 <code class="highlighter-rouge">wycats의 http</code>나 <code class="highlighter-rouge">reem의 http</code> 같은 식으로 가리켜야 한다는 뜻일 뿐입니다.
<code class="highlighter-rouge">wycats-http</code>나 <code class="highlighter-rouge">reem-http</code> 같은 패키지 이름에 비해 별달리 장점이 없지요.<br /><br /></p>

  <p>이름 공간이 없는 패키지 생태계들을 살펴 본 결과 사람들이 (“tenderlove의 libxml2” 대신 <code class="highlighter-rouge">nokogiri</code> 같이) 더 창의적인 이름들을 쓰는 편이라는 걸 알게 되었습니다.
아무런 계층도 담고 있지 않는다는 것도 있고 해서, 이런 창의적인 이름들은 짧고 기억하기 쉬운 편입니다.
이들은 패키지에 대해 간결하고 모호함 없이 소통하기 쉽게 만들고, 신나는 브랜드를 만들지요.
또한 우리는 NPM이나 RubyGems 같이 수만개의 패키지가 있는 성공적인 생태계에서 커뮤니티가 하나의 이름 공간만으로 번창하는 것 또한 보아 왔습니다.<br /><br /></p>

  <p>요약하자면 우리는 Piston이 단순히 <code class="highlighter-rouge">piston</code> 대신 <code class="highlighter-rouge">bvssvni/game-engine</code> 같은 이름을 선택했다고 해서 (그래서 다른 사용자가 <code class="highlighter-rouge">wycats/game-engine</code>을 고를 수 있게 된다 해서) Cargo 생태계가 더 좋아질 거라고 생각하지 않습니다.<br /><br /></p>

  <p>이름 공간은 그 자체로 여러 방면에서 복잡하고, 나중에 필요해진다면 호환되는 방법으로 추가할 수 있다는 점에서, 우리는 하나의 공유된 이름 공간을 계속 쓰려고 합니다.</p>
</blockquote>

<h2 id="libraries">라이브러리</h2>

<h3><a href="#how-can-i-make-an-http-request" name="how-can-i-make-an-http-request">
HTTP 요청을 어떻게 보내나요?
</a></h3>

<p>표준 라이브러리에는 HTTP 구현이 포함되어 있지 않으므로 외부 크레이트를 사용해야 합니다.
가장 간단하게는 <a href="http://docs.rs/reqwest">reqwest</a>가 있습니다.
<a href="https://github.com/hyperium/hyper">hyper</a>를 써서 Rust로 만들어져 있고, <a href="https://crates.io/keywords/http">다른 라이브러리들도 여럿 있습니다</a>.
<a href="https://docs.rs/curl">curl</a> 크레이트는 curl 라이브러리의 바인딩을 제공하는 널리 쓰이는 라이브러리입니다.</p>

<h3><a href="#how-can-i-write-a-gui-application" name="how-can-i-write-a-gui-application">
Rust로 GUI 애플리케이션을 작성하려면 어떻게 해야 하나요?
</a></h3>

<p>Rust로 GUI 애플리케이션을 만드는 방법은 여럿 있습니다. <a href="https://github.com/kud1ing/awesome-rust#gui">GUI 프레임워크들의 목록</a>을 참고하세요.</p>

<h3><a href="#how-can-i-parse-json-xml" name="how-can-i-parse-json-xml">
JSON/XML을 파싱하는 방법은 무엇인가요?
</a></h3>

<p><a href="https://github.com/serde-rs/serde">Serde</a>는 Rust 데이터를 다른 여러 포맷으로 직렬화(serialize)하고 역직렬화(deserialize)하는데 추천하는 라이브러리입니다.</p>

<h3><a href="#is-there-a-standard-2d-vector-crate" name="is-there-a-standard-2d-vector-crate">
표준 2차원/3차원/... 벡터 및 도형 크레이트가 있나요?
</a></h3>

<p>아직요! 만들어 보실래요?</p>

<h3><a href="#how-do-i-write-an-opengl-app" name="how-do-i-write-an-opengl-app">
Rust로 OpenGL 앱을 작성하려면 어떻게 해야 하죠?
</a></h3>

<p><a href="https://github.com/tomaka/glium">Glium</a>는 Rust에서 OpenGL 프로그래밍에 쓰이는 주요 라이브러리입니다.
<a href="https://github.com/bjz/glfw-rs">GLFW</a> 또한 괜찮은 대안입니다.</p>

<h3><a href="#can-i-write-a-video-game-in-rust" name="can-i-write-a-video-game-in-rust">
Rust로 비디오 게임을 만들 수 있나요?
</a></h3>

<p>가능합니다!
Rust로 만들어진 주요 게임 프로그래밍 라이브러리는 <a href="http://www.piston.rs/">Piston</a>이 있으며, <a href="https://www.reddit.com/r/rust_gamedev/">Rust 게임 프로그래밍을 위한 서브레딧</a>과 IRC 채널(<a href="https://wiki.mozilla.org/IRC">Mozilla IRC</a>의 <code class="highlighter-rouge">#rust-gamedev</code> 채널)도 있습니다.</p>

<h2 id="design-patterns">디자인 패턴</h2>

<h3><a href="#is-rust-object-oriented" name="is-rust-object-oriented">
Rust는 객체 지향적(object-oriented)인가요?
</a></h3>

<p>Rust는 여러 패러다임을 지원합니다.
객체 지향 언어에서 할 수 있는 많은 것들은 Rust에서도 할 수 있지만, 전부 가능한 건 아니고, 여러분에게 익숙한 추상화를 사용하지 않을 수도 있습니다.</p>

<h3><a href="#how-do-i-map-object-oriented-concepts-to-rust" name="how-do-i-map-object-oriented-concepts-to-rust">
객체 지향적인 개념을 Rust에 어떻게 대응시키죠?
</a></h3>

<p>상황에 따라 다릅니다.
<a href="https://www.reddit.com/r/rust/comments/2sryuw/ideaquestion_about_multiple_inheritence/">다중 상속</a>과 같은 객체 지향 개념을 Rust로 옮기는 방법은 <em>여럿</em> 있습니다만, Rust는 객체 지향이 아니기에 객체 지향 언어들과는 상당히 다르게 보일 수 있습니다.</p>

<h3><a href="#how-do-i-configure-a-struct-with-optional-parameters" name="how-do-i-configure-a-struct-with-optional-parameters">
선택 인자가 있는 구조체를 설정하는 인터페이스를 어떻게 만들어야 할까요?
</a></h3>

<p>가장 쉬운 방법은 구조체 인스턴스를 생성하는 어떤 함수에든 (보통 <code class="highlighter-rouge">new()</code>에) <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code class="highlighter-rouge">Option</code></a> 타입을 쓰는 겁니다.
또 다른 방법은 <a href="https://doc.rust-lang.org/stable/book/first-edition/method-syntax.html#builder-pattern">빌더(builder) 패턴</a>을 써서, 타입을 생성하기 전에 멤버 변수를 인스턴스화하는 특정 함수들을 호출해야 하도록 하는 것입니다.</p>

<h3><a href="#how-do-i-do-global-variables" name="how-do-i-do-global-variables">
Rust에서 전역 변수를 쓰려면 어떻게 하죠?
</a></h3>

<p>Rust에서 전역 변수는 컴파일 시간에 계산된 전역 상수라면 <code class="highlighter-rouge">const</code> 선언을 쓸 수 있고, 변경 가능한 전역 변수는 <code class="highlighter-rouge">static</code>을 쓸 수 있습니다.
다만 <code class="highlighter-rouge">static mut</code> 변수를 변경하려면 <code class="highlighter-rouge">unsafe</code>가 필요한데, 이는 안전한 Rust에서는 발생하지 않는다고 보장하는 데이터 레이스(data race)가 일어날 수 있기 때문입니다.
<code class="highlighter-rouge">const</code>와 <code class="highlighter-rouge">static</code> 값의 중요한 차이는 <code class="highlighter-rouge">static</code>에서는 참조를 얻을 수 있지만 <code class="highlighter-rouge">const</code>는 지정된 메모리 위치를 가지지 않기 때문에 불가능하다는 점입니다.
<code class="highlighter-rouge">const</code>와 <code class="highlighter-rouge">static</code>에 대해 더 자세한 정보에 대해서는 <a href="https://doc.rust-lang.org/book/const-and-static.html">《Rust 프로그래밍 언어》를 읽으세요</a>.</p>

<h3><a href="#how-can-i-set-compile-time-constants-that-are-defined-procedurally" name="how-can-i-set-compile-time-constants-that-are-defined-procedurally">
절차적으로 정의되는 컴파일 시간 상수는 어떻게 설정하나요?
</a></h3>

<p>Rust는 현재 컴파일 시간 상수를 제한적으로 지원합니다.
원시 값을 <code class="highlighter-rouge">const</code> 선언으로 정의할 수 있고(<code class="highlighter-rouge">static</code>과 비슷하지만, 변경할 수 없고 메모리에서 지정된 위치를 가지지 않습니다), <code class="highlighter-rouge">const</code> 함수나 선천적인 메소드도 정의할 수 있습니다.</p>

<p>이 기작으로 선언할 수 없는 명령적인 상수를 선언하려면 <a href="https://github.com/rust-lang-nursery/lazy-static.rs"><code class="highlighter-rouge">lazy-static</code></a> 크레이트를 사용하세요.
이 크레이트는 컴파일 시간 평가를 상수가 처음 사용될 때 자동으로 평가하는 걸로 흉내냅니다.</p>

<h3><a href="#can-i-run-code-before-main" name="can-i-run-code-before-main">
`main` 이전에 실행되는 초기화 코드를 만들 수 있나요?
</a></h3>

<p>Rust에는 “<code class="highlighter-rouge">main</code> 이전의 삶”이라는 개념이 없습니다.
<a href="https://github.com/Kimundi/lazy-static.rs"><code class="highlighter-rouge">lazy-static</code></a> 크레이트가 가장 가까운 것일텐데, 이 크레이트는 “main보다 이전”이라는 시간을 정적 변수를 처음 사용할 때 지연하여 초기화하는 걸로 흉내냅니다.</p>

<!--

This answer needs significant work. Let's revise after the initial posting. --aturon

<h3><a href="#why-doesnt-rust-have-inheritance" name="why-doesnt-rust-have-inheritance">
Why doesn't Rust have inheritance?
</a></h3>

There are two meanings for the word "inheritance": _subtyping_, and _interface sharing_. Both purposes are already handled by traits.

For the first, subtyping exists for polymorphism, which traits already provide.

For the second, interface sharing is handled via trait methods, which define a collection of related functions that must be implemented for any implementation of the trait.

Rust has consistently worked to avoid having features with overlapping purposes, preferring to keep features orthogonal. For this reason, and given that the two major purposes are already handled by traits, Rust has opted not to include inheritance.

-->

<h3><a href="#does-rust-allow-non-constant-expression-values-for-globals" name="does-rust-allow-non-constant-expression-values-for-globals">
Rust에서 상수 수식이 아닌 값을 전역에 넣을 수 있나요?
</a></h3>

<p>아니요.
전역 변수는 상수 수식이 아닌 생성자를 가질 수 없고 소멸자를 아예 가질 수 없습니다.
정적 생성자는 정적 초기화 순서를 이식성 있는 방법으로 보장하는 게 어려워서 바람직하지 않습니다.
main 이전의 삶은 종종 잘못된 기능으로 꼽히므로, Rust에서는 허용되지 않습니다.</p>

<p><a href="http://yosefk.com/c++fqa/ctors.html#fqa-10.12">C++ FQA</a>에서 “정적 초기화 순서 사기” 부분과, 이 기능을 가지고 있는 C#에서의 도전을 다루는 <a href="https://ericlippert.com/2013/02/06/static-constructors-part-one/">Eric Lippert의 블로그</a>도 보세요.</p>

<p>상수 수식이 아닌 전역 변수는 <a href="https://crates.io/crates/lazy_static/">lazy-static</a> 크레이트로 근사할 수 있습니다.</p>

<h2 id="other-languages">다른 언어들</h2>

<h3><a href="#how-can-i-use-static-fields" name="how-can-i-use-static-fields">
C의 <code>struct X { static int X; };</code> 같은 코드를 Rust에서는 어떻게 만드나요?
</a></h3>

<p>Rust는 위의 코드 조각에 쓰여진 식의 <code class="highlighter-rouge">static</code> 필드가 없습니다.
대신 주어진 모듈에서만 볼 수 있는 <code class="highlighter-rouge">static</code> 변수를 선언할 수 있습니다.</p>

<h3><a href="#how-can-i-convert-a-c-style-enum-to-an-integer" name="how-can-i-convert-a-c-style-enum-to-an-integer">
C 스타일의 열거형을 정수로 바꾸거나 반대로 하려면 어떻게 하나요?
</a></h3>

<p>C 스타일의 열거형은 (<code class="highlighter-rouge">e</code>가 열거형일 때) <code class="highlighter-rouge">e as i64</code> 같은 식으로 <code class="highlighter-rouge">as</code> 수식으로 정수로 바꿀 수 있습니다.</p>

<p>반대로 바꾸려면 <code class="highlighter-rouge">match</code> 문장을 써서, 서로 다른 숫자 값들을 열거형의 서로 다른 가능한 값들로 대응시킬 수 있습니다.</p>

<h3><a href="#why-do-rust-programs-have-larger-binary-sizes-than-C-programs" name="why-do-rust-programs-have-larger-binary-sizes-than-C-programs">
왜 Rust 프로그램의 바이너리 크기가 C 프로그램보다 큰 거죠?
</a></h3>

<p>Rust 프로그램이 동작이 같은 C 프로그램보다 기본값으로 더 큰 바이너리 크기를 가지는 데 영향을 미치는 여러 요소가 있습니다.
일반적으로 Rust는 작은 프로그램의 크기보다는 현실 프로그램의 성능을 최적화하는 걸 선호합니다.</p>

<p><strong>단형화</strong></p>

<p>Rust는 일반화된 코드를 단형화하는데, 이는 일반화된 함수나 타입이 프로그램에서 쓰인 구체적인 타입마다 새 버전으로 생성된다는 뜻입니다.
이는 C++에서 템플릿이 동작하는 방법과 비슷합니다.
예를 들어 다음 프로그램에서는:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="n">foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ... 뭔가를 함</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">foo</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>       <span class="c">// i32</span>
    <span class="nf">foo</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>  <span class="c">// &amp;str</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">foo</code>의 서로 다른, 하나는 <code class="highlighter-rouge">i32</code> 입력으로 특수화되고 다른 하나는 <code class="highlighter-rouge">&amp;str</code> 입력으로 특수화된, 두 개의 버전이 최종 바이너리에 들어가게 됩니다.
이는 일반화된 함수의 정적 디스패치를 효율적으로 만들지만 바이너리 크기의 비용을 치루어야 합니다.</p>

<p><strong>디버그 기호</strong></p>

<p>Rust 프로그램은 릴리스 모드일 때도 일부 디버그 기호가 유지된 채로 컴파일됩니다.
이는 패닉시 스택 추적(backtrace)을 제공하는 데 쓰이고, <code class="highlighter-rouge">strip</code>이나 다른 기호 제거 도구로 지울 수 있습니다.
Cargo에서 릴리스 모드로 컴파일할 경우 rustc에서 최적화 레벨 3을 설정하는 거랑 같다는 것도 지적해야 겠네요.
대안 최적화 레벨(<code class="highlighter-rouge">s</code> 또는 <code class="highlighter-rouge">z</code>라고 부릅니다)이 <a href="https://github.com/rust-lang/rust/pull/32386">최근에 들어 왔으며</a> 이걸로 성능 대신 크기를 최적화해 달라고 컴파일러한테 말할 수 있습니다.</p>

<p><strong>Jemalloc</strong></p>

<p>Rust는 기본 할당자(allocator)로 jemalloc을 쓰기 때문에 컴파일된 Rust 바이너리에 얼마간의 크기가 추가됩니다.
Jemalloc은 흔히 쓰이는 시스템에서 제공하는 할당자에 비해 성능 특징이 더 나은 일관되고 질 좋은 할당자라 선택되었습니다.
<a href="https://github.com/rust-lang/rust/issues/32838">사용자 정의 할당자를 더 쉽게 쓸 수 있게 하는 작업</a>이 진행 중입니다만 아직 완료되진 않았습니다.</p>

<p><strong>링크 시간 최적화</strong></p>

<p>Rust는 기본값으로 링크 시간 최적화(link-time optimization)를 하지 않지만 이를 하도록 지정할 수 있습니다.
이 최적화는 Rust 컴파일러가 잠재적으로 할 수 있는 최적화의 양을 늘리며, 바이너리 크기에도 작은 영향을 줄 수 있습니다.
앞에서 언급한 크기 최적화 모드와 함께 쓰면 더 큰 효과가 있을 것입니다.</p>

<p><strong>표준 라이브러리</strong></p>

<p>Rust 표준 라이브러리에는 libbacktrace와 libunwind가 들어 가는데 일부 프로그램에서는 바람직하지 않을 수 있습니다.
따라서 <code class="highlighter-rouge">#![no_std]</code>를 쓰면 작은 바이너리가 나올 수 있지만, 보통 작성 중인 Rust 코드에 작지 않은 변화가 필요하게 됩니다.
Rust를 표준 라이브러리 없이 사용하는 게 종종 동일한 C 코드와 기능적으로 유사하다는 점도 지적해 둡니다.</p>

<p>예를 들어 다음 C 프로그램은 이름을 읽어서 그 이름을 가진 사람한테 “hello”라고 말합니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"What's your name?</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">input</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello %s!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Rust로 이걸 재작성하면 대략 다음과 같은 게 되는데요:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"What's your name?"</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {}!"</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>이 프로그램을 컴파일해서 C 프로그램과 비교하면 바이너리가 더 크고 더 많은 메모리를 쓸 겁니다.
하지만 이 프로그램은 위 C 코드와 완전히 동일하지 않습니다.
동일한 Rust 코드는 대신 다음과 비슷하게 생겼을 겁니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="nf">feature</span><span class="p">(</span><span class="n">lang_items</span><span class="p">)]</span>
<span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="nf">feature</span><span class="p">(</span><span class="n">libc</span><span class="p">)]</span>
<span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="nf">feature</span><span class="p">(</span><span class="n">no_std</span><span class="p">)]</span>
<span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="nf">feature</span><span class="p">(</span><span class="n">start</span><span class="p">)]</span>
<span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="n">no_std</span><span class="p">]</span>

<span class="k">extern</span> <span class="n">crate</span> <span class="n">libc</span><span class="p">;</span>

<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="err">...</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">scanf</span><span class="p">(</span><span class="n">fmt</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="err">...</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#[start]</span>
<span class="k">fn</span> <span class="nf">start</span><span class="p">(</span><span class="n">_argc</span><span class="p">:</span> <span class="n">isize</span><span class="p">,</span> <span class="n">_argv</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">isize</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nf">printf</span><span class="p">(</span><span class="n">b</span><span class="s">"What's your name?</span><span class="se">\n</span><span class="err">\</span><span class="s">0"</span><span class="nf">.as_ptr</span><span class="p">());</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">100</span><span class="p">];</span>
        <span class="nf">scanf</span><span class="p">(</span><span class="n">b</span><span class="s">"</span><span class="si">%s</span><span class="err">\</span><span class="s">0"</span><span class="nf">.as_ptr</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">);</span>
        <span class="nf">printf</span><span class="p">(</span><span class="n">b</span><span class="s">"Hello </span><span class="si">%s</span><span class="s">!</span><span class="se">\n</span><span class="err">\</span><span class="s">0"</span><span class="nf">.as_ptr</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>
        <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[lang=</span><span class="s">"eh_personality"</span><span class="cp">]</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">eh_personality</span><span class="p">()</span> <span class="p">{}</span>
<span class="cp">#[lang=</span><span class="s">"panic_fmt"</span><span class="cp">]</span> <span class="k">fn</span> <span class="nf">panic_fmt</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">!</span> <span class="p">{</span> <span class="k">loop</span> <span class="p">{}</span> <span class="p">}</span>
<span class="cp">#[lang=</span><span class="s">"stack_exhausted"</span><span class="cp">]</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">stack_exhausted</span><span class="p">()</span> <span class="p">{}</span>
</code></pre>
</div>

<p>실제로 이 코드는 C와 대비해서 메모리 사용량이 비슷하겠지만, 대신 프로그래머에게 더 많은 복잡도를 지우고, Rust가 보통 제공하는 정적인 보장들 또한 없습니다(여기서는 <code class="highlighter-rouge">unsafe</code>를 써서 보장을 제거했습니다).</p>

<h3><a href="#why-no-stable-abi" name="why-no-stable-abi">
왜 Rust는 C 같이 안정화된 ABI가 없는 건가요? 그리고 왜 `extern`을 달아야 하는 거죠?
</a></h3>

<p>ABI에 노력을 투자하는 건 앞으로 가능한, 어쩌면 득이 될 수도 있는 언어 변경을 제한할 수 있는 큰 결정입니다.
Rust가 2015년 5월에야 1.0이 되었다는 걸 볼 때 안정된 ABI 같은 큰 투자를 하기에는 아직 너무 이릅니다.
하지만 미래에도 일어나지 않을 거라는 얘기는 아닙니다.
(C++가 오랫동안 안정된 ABI를 명시하지 않은 채 유지되긴 했지만요.)</p>

<p><code class="highlighter-rouge">extern</code> 예약어를 쓰면 Rust가 잘 정의된 C ABI 같이 특정한 ABI를 써서 다른 언어와 상호작용하도록 할 수 있습니다.</p>

<h3><a href="#can-rust-code-call-c-code" name="can-rust-code-call-c-code">
Rust 코드가 C 코드를 호출할 수 있나요?
</a></h3>

<p>네.
C 코드를 Rust에서 부르는 것은 C++에서 C 코드를 부르는 것만큼 효율적이도록 설계되었습니다.</p>

<h3><a href="#can-c-code-call-rust-code" name="can-c-code-call-rust-code">
C 코드가 Rust 코드를 호출할 수 있나요?
</a></h3>

<p>네.
Rust 코드가 <code class="highlighter-rouge">extern</code> 선언으로 노출되어 C의 ABI와 호환되도록 만들어야 합니다.
이러한 함수는 C 코드에 함수 포인터로 전달되거나, <code class="highlighter-rouge">#[no_mangle]</code> 속성으로 기호 꾸미기(symbol mangling)를 껐을 경우, C 코드에서 바로 호출될 수 있습니다.</p>

<h3><a href="#why-rust-vs-cxx" name="why-rust-vs-cxx">
전 이미 C++를 완벽하게 짤 수 있는데, Rust가 어떤 잇점이 있나요?
</a></h3>

<p>현대적인 C++는 안전하고 올바른 코드를 짜기 더 수월하도록 하는 많은 기능들을 가지고 있습니다만, 완벽한 건 아니고 여전히 위험을 불러오기가 쉽습니다.
C++ 코어 개발자들은 이 문제를 해결하려 노력하고 있지만, C++는 그들이 지금 구현하려 하는 많은 아이디어에 앞서는 오랜 역사로 제약을 받습니다.</p>

<p>Rust는 첫 날부터 안전한 시스템 프로그래밍 언어로 설계되었으며, 이는 C++를 제대로 안전하게 만들기를 매우 복잡하게 만드는 역사적인 설계 결정들에 제한을 받지 않는다는 뜻입니다.
C++에서 안전성은 주의깊은 개인적인 규율로 달성되고 틀리기 매우 쉽습니다.
Rust에서 안전성은 기본값입니다.
Rust는 여러분보다 덜 완전한 사람들을 포함하는 팀에서, 안전성 버그를 피하려 그들의 코드를 재확인하는 데 시간을 쓸 필요가 없이 함께 일할 수 있도록 합니다.</p>

<h3><a href="#how-to-get-cxx-style-template-specialization" name="how-to-get-cxx-style-template-specialization">
C++의 템플릿 특수화 같은 걸 Rust에서는 어떻게 할 수 있을까요?
</a></h3>

<p>Rust는 현재 템플릿 특수화와 완전히 같은 기능을 가지고 있지 않지만, <a href="https://github.com/rust-lang/rfcs/pull/1210">현재 작업이 진행 중</a>이며 아마 곧 추가될 것입니다.
다만 <a href="https://doc.rust-lang.org/stable/book/associated-types.html">연관 타입</a>으로 비슷한 결과를 얻을 수도 있습니다.</p>

<h3><a href="#how-does-ownership-relate-to-cxx-move-semantics" name="how-does-ownership-relate-to-cxx-move-semantics">
Rust의 소유권 시스템이 C++의 "이동" 의미론과 어떻게 연관되나요?
</a></h3>

<p>기반 개념은 비슷하지만 실제로는 두 시스템은 굉장히 다르게 동작합니다.
두 시스템 모두에서 값을 “옮기는” 건 기반하는 자원의 소유권을 이전하는 방법입니다.
예를 들어 문자열을 옮긴다면 문자열의 버퍼를 복사하는 대신 이전하기만 할 겁니다.</p>

<p>Rust에서 소유권 이전은 기본 동작입니다.
예를 들어 <code class="highlighter-rouge">String</code>을 인자로 받는 함수를 만들었다면, 이 함수는 호출하는 쪽에서 지급한 <code class="highlighter-rouge">String</code> 값의 소유권을 가져 갑니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">process</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">fn</span> <span class="nf">caller</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">);</span>
    <span class="nf">process</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c">// `s`의 소유권을 `process`로 넘김</span>
    <span class="nf">process</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c">// 오류! 소유권이 이미 이전됨.</span>
<span class="p">}</span>
</code></pre>
</div>

<p>위 조각에서 볼 수 있듯 <code class="highlighter-rouge">caller</code> 함수에서 <code class="highlighter-rouge">process</code>의 첫 호출은 변수 <code class="highlighter-rouge">s</code>의 소유권을 이전합니다.
컴파일러는 소유권을 추적하고, 따라서 <code class="highlighter-rouge">process</code>의 두번째 호출에서는 같은 값의 소유권을 두 번 주는 게 불법이기에 오류가 납니다.
Rust는 또한 값에 현재 진행형인 참조가 존재할 경우 값을 옮길 수 없게 할 것입니다.</p>

<p>C++는 다른 접근을 취합니다.
C++에서 기본값은 값을 복사(좀 더 정확히는 복사 생성자를 호출)하는 것입니다.
하지만 호출되는 함수가 그 인자를 <code class="highlighter-rouge">string&amp;&amp;</code> 같이 “rvalue 참조”로 선언할 수 있으며, 이는 그들이 그 인자가 소유한 일부 자원(이 경우 문자열의 내부 버퍼)의 소유권을 넘겨 받을 거라는 걸 나타냅니다.
이 때 호출하는 함수는 임시 수식을 넘기거나 <code class="highlighter-rouge">std::move</code>로 명시적으로 옮겨야 합니다.
따라서 위의 <code class="highlighter-rouge">process</code> 함수와 대략적으로 같은 코드는 다음과 같을 것입니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void process(string&amp;&amp; s) { }

void caller() {
    string s("Hello, world!");
    process(std::move(s));
    process(std::move(s));
}
</code></pre>
</div>

<p>C++ 컴파일러는 이동을 추적할 의무가 없습니다.
예를 들어 위 코드는, 적어도 clang의 기본 설정에서는, 경고나 오류를 내지 않고 컴파일됩니다.
게다가 C++에서 (내장 버퍼 말고) <code class="highlighter-rouge">s</code> 자신의 소유권은 <code class="highlighter-rouge">caller</code>에 남기 때문에, <code class="highlighter-rouge">caller</code>가 반환될 때 <code class="highlighter-rouge">s</code>가 분명 이동했음에도 소멸자가 불리게 됩니다(반대로 Rust에서 이동된 값은 새 소유권자에 의해서만 소멸됩니다).</p>

<h3><a href="#how-to-interoperate-with-cxx" name="how-to-interoperate-with-cxx">
C++에서 Rust와 상호작용하거나, Rust에서 C++와 상호작용하려면 어떻게 하나요?
</a></h3>

<p>Rust와 C++ 둘 다 C와 상호작용할 수 있습니다.
Rust와 C++ 모두 C와 <a href="https://doc.rust-lang.org/book/ffi.html">외부 함수 인터페이스</a>를 제공하며, 이를 각자와 소통하기 위해 쓸 수 있습니다.
C 바인딩을 만드는 게 너무 지루하다면, 언제나 <a href="https://github.com/servo/rust-bindgen">rust-bindgen</a>을 써서 자동으로 동작하는 C 바인딩을 만드는 데 도움을 받을 수 있습니다.</p>

<h3><a href="#does-rust-have-cxx-style-constructors" name="does-rust-have-cxx-style-constructors">
Rust에는 C++ 같은 생성자가 있나요?
</a></h3>

<p>아뇨.
추가적인 언어 복잡도 없이 함수가 생성자와 같은 역할을 수행합니다.
Rust에서 생성자에 대응되는 함수의 일반적인 이름은 <code class="highlighter-rouge">new()</code>로, 이는 언어 규칙이 아니라 단순한 규약일 따름입니다.
<code class="highlighter-rouge">new()</code> 함수는 다른 함수랑 다를 바가 없고, 이런 식으로 씁니다:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Foo</span> <span class="p">{</span>
        <span class="n">Foo</span> <span class="p">{</span>
            <span class="n">a</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">b</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="n">c</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h3><a href="#does-rust-have-copy-constructors" name="does-rust-have-copy-constructors">
Rust에는 복사 생성자가 있나요?
</a></h3>

<p>정확히는 아닙니다.
<code class="highlighter-rouge">Copy</code>를 구현하는 타입은 C랑 비슷하게, 추가 작업 없이 표준적인 “얕은(shallow) 복사”를 하게 됩니다(이는 C++에서 자명하게 복사할 수 있는 타입들과 비슷합니다).
사용자 정의된 복사 동작이 필요한 <code class="highlighter-rouge">Copy</code> 타입을 구현하는 건 불가능합니다.
대신 Rust에서 “복사 생성자”는 <code class="highlighter-rouge">Clone</code> 트레이트를 구현하여 명시적으로 <code class="highlighter-rouge">clone</code> 메소드를 호출하는 걸로 만들어집니다.
사용자 정의된 복사 연산자를 명시적으로 만드는 건 그 아래의 복잡도를 보여 주며, 개발자가 잠재적으로 비싼 연산을 파악하기 더 쉽게 만듭니다.</p>

<h3><a href="#does-rust-have-move-constructors" name="does-rust-have-move-constructors">
Rust에는 이동 생성자가 있나요?
</a></h3>

<p>아뇨.
모든 타입의 값들은 <code class="highlighter-rouge">memcpy</code>로 옮겨집니다.
덕분에 일반적인 안전하지 않은 코드를 짜기 훨씬 간단해지는데, 대입이나 인자를 넘기고 반환하는 과정에서 되감기(unwinding) 같은 부수 효과가 일어날 수 없다는 걸 보장할 수 있기 때문입니다.</p>

<h3><a href="#compare-go-and-rust" name="compare-go-and-rust">
Go와 Rust가 비슷한 점은 무엇이고 다른 점은 무엇인가요?
</a></h3>

<p>Rust와 Go는 상당히 다른 설계 목표를 가집니다.
전부는 아니지만(다 나열하기에는 많습니다), 다음 차이들이 가장 중요하다고 볼 수 있습니다:</p>

<ul>
  <li>Rust는 Go보다 저수준입니다. 예를 들어 Rust는 쓰레기 수거기(garbage collector)를 필요하지 않지만 Go는 필요로 합니다. 일반적으로 Rust는 C나 C++와 비견할 만한 제어 수준을 제공합니다.</li>
  <li>Rust의 촛점은 고수준의 편안함을 제공하면서도 안전함과 효율성을 보장하는 것이며, Go의 촛점은 빠르게 컴파일되고 수많은 도구와 함께 멋지게 동작할 수 있는 작고 간단한 언어가 되고자 하는 것입니다.</li>
  <li>Rust는 일반화 코드에 대한 강한 지원을 가지고 있지만 Go는 아닙니다.</li>
  <li>Rust는 함수형 프로그래밍에서 많은 영향을 받았으며, 여기에는 하스켈의 타입 클래스에서 유래한 타입 시스템이 포함됩니다. Go는 더 단순한 타입 시스템을 가지고 있고 기본적인 일반화 프로그래밍을 위해 인터페이스를 사용합니다.</li>
</ul>

<h3><a href="#how-do-rust-traits-compare-to-haskell-typeclasses" name="how-do-rust-traits-compare-to-haskell-typeclasses">
Rust 트레이트를 하스켈 타입 클래스와 비교하면 어떤가요?
</a></h3>

<p>Rust 트레이트는 하스켈 타입 클래스와 비슷하지만, Rust가 상류(higher-kinded) 타입을 표현할 수 없기 때문에 덜 강력합니다.
Rust의 연관 타입은 하스켈의 타입 무리(type family)와 동일합니다.</p>

<p>하스켈 타입 클래스와 Rust 트레이트 사이에 구체적인 차이로는 이런 게 있습니다:</p>

<ul>
  <li>Rust 트레이트는 암묵적인 첫 파라미터 <code class="highlighter-rouge">Self</code>를 받습니다. Rust에서 <code class="highlighter-rouge">trait Bar</code>는 하스켈에서 <code class="highlighter-rouge">class Bar self</code>에 대응하고, Rust에서 <code class="highlighter-rouge">trait Bar&lt;foo&gt;</code>는 하스켈에서 <code class="highlighter-rouge">class Bar foo self</code>에 대응합니다.</li>
  <li>Rust에서 “상위 트레이트”나 “상위 클래스 제약”은 <code class="highlighter-rouge">trait Sub: Super</code>라고 쓰는데 하스켈에서는 <code class="highlighter-rouge">class Super self =&gt; Sub self</code>라고 씁니다.</li>
  <li>Rust에서는 홀로 떨어진(orphan) 인스턴스를 금지하며, 따라서 Rust의 일관성(coherence) 규칙은 하스켈과 다릅니다.</li>
  <li>Rust의 <code class="highlighter-rouge">impl</code> 해소 과정에서는 두 <code class="highlighter-rouge">impl</code>이 겹치거나 잠재적인 <code class="highlighter-rouge">impl</code>들 사이에서 선택할 때 관련된 <code class="highlighter-rouge">where</code> 절과 트레이트 제약을 살펴 봅니다. 하스켈은 오로지 <code class="highlighter-rouge">instance</code> 선언에 있는 제약 조건만 살펴 보며 다른 곳에서 제공한 제약은 무시합니다.</li>
  <li>Rust 트레이트의 부분집합(<a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">“객체 안전(object safe)”</a>한 것들)은 트레이트 객체를 통한 동적 디스패치에 쓰일 수 있습니다. 같은 기능이 하스켈에서는 GHC의 <code class="highlighter-rouge">ExistentialQuantification</code>으로 제공됩니다.</li>
</ul>

<h2 id="documentation">문서</h2>

<h3><a href="#why-are-so-many-rust-answers-on-stackoverflow-wrong" name="why-are-so-many-rust-answers-on-stackoverflow-wrong">
왜 Stack Overflow의 Rust 답변 중에는 틀린 게 많은가요?
</a></h3>

<p>Rust 언어는 여러 해 동안 개발되어 왔으며, 2015년 5월에서야 1.0 버전에 도달했습니다.
그 이전에는 언어가 상당히 많이 바뀌었고 Stack Overflow의 답변 중 많은 것들은 언어가 옛날 버전일 때 작성된 것입니다.</p>

<p>시간이 지날수록 더 많은 답변이 현재 버전을 기준으로 작성되고, 따라서 오래된 답변의 비율이 줄어들 것이므로 이 문제는 자연히 개선될 것입니다.</p>

<h3><a href="#where-do-i-report-issues-in-the-rust-documentation" name="where-do-i-report-issues-in-the-rust-documentation">
Rust 문서에 문제를 보고하려면 어디에 하나요?
</a></h3>

<p>Rust 문서의 문제는 Rust 컴파일러의 <a href="https://github.com/rust-lang/rust/issues">이슈 트래커</a>에 보고할 수 있습니다.
보고에 앞서 먼저 <a href="https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#writing-documentation">기여 가이드라인</a>을 읽어 주세요.</p>

<h3><a href="#how-do-i-view-rustdoc-documentation-for-a-library-my-project-depends-on" name="how-do-i-view-rustdoc-documentation-for-a-library-my-project-depends-on">
제 프로젝트가 의존하는 라이브러리의 rustdoc 문서를 어떻게 볼 수 있나요?
</a></h3>

<p><code class="highlighter-rouge">cargo doc</code>으로 프로젝트의 문서를 생성할 때는 활성화되어 있는 의존하는 버전들의 문서도 함께 생성됩니다.
이들은 프로젝트의 <code class="highlighter-rouge">target/doc</code> 디렉토리에 저장됩니다.
<code class="highlighter-rouge">cargo doc --open</code>으로 문서가 생성된 뒤에 문서를 열어 보거나, 아니면 직접 <code class="highlighter-rouge">target/doc/index.html</code>을 열어 보세요.</p>


</div>

</div>


    <footer>
      <p>이 사이트를 다른 언어로 보기:
        <a href="/de-DE/">Deutsch</a>,
<a href="/en-US/">English</a>,
<a href="/es-ES/">Español</a>,
<a href="/fr-FR/">Français</a>,
<a href="/id-ID/">Bahasa Indonesia</a>,
<a href="/it-IT/">Italiano</a>,
<a href="/ja-JP/">日本語</a>,
<a href="/ko-KR/">한국어</a>,
<a href="/pl-PL/">Polski</a>,
<a href="/pt-BR/">Português</a>,
<a href="/ru-RU/">Русский</a>,
<a href="/sv-SE/">Svenska</a>,
<a href="/vi-VN/">Tiếng việt</a>,
<a href="/zh-CN/">简体中文</a>

      </p>
    </footer>
  </body>
</html>
